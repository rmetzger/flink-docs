<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Apache Flink 1.1-SNAPSHOT Documentation: Gelly: Flink Graph API</title>
    <link rel="shortcut icon" href="/page/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/page/favicon.ico" type="image/x-icon">

    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="/page/css/flink.css">
    <link rel="stylesheet" href="/page/css/syntax.css">
    <link rel="stylesheet" href="/page/css/codetabs.css">
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    
    





    <!-- Top navbar. -->
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <!-- The logo. -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <div class="navbar-logo">
            <a href="http://flink.apache.org"><img alt="Apache Flink" src="/page/img/navbar-brand-logo.jpg"></a>
          </div>
        </div><!-- /.navbar-header -->

        <!-- The navigation links. -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <li class="hidden-sm "><a href="/">Docs v1.1</a></li>

            <li class=""><a href="/concepts/concepts.html">Concepts</a></li>

            <!-- Setup -->
            <li class="dropdown">
              <a href="/setup" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Setup <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                
                
                <li class=""><a href="/setup/building.html">Build Flink from Source</a></li>
                
                <li class=""><a href="/setup/config.html">Configuration</a></li>
                

                <li class="divider"></li>
                <li role="presentation" class="dropdown-header"><strong>Quickstart</strong></li>

                <!-- Quickstart -->
                
                
                <li class=""><a href="/quickstart/setup_quickstart.html">Setup & Run Example</a></li>
                
                <li class=""><a href="/quickstart/java_api_quickstart.html">Java API</a></li>
                
                <li class=""><a href="/quickstart/scala_api_quickstart.html">Scala API</a></li>
                

                <li class="divider"></li>
                <li role="presentation" class="dropdown-header"><strong>Deployment</strong></li>
                
                
                <li class=""><a href="/setup/local_setup.html">Local</a></li>
                
                <li class=""><a href="/setup/cluster_setup.html">Cluster (Standalone)</a></li>
                
                <li class=""><a href="/setup/yarn_setup.html">YARN</a></li>
                
                <li class=""><a href="/setup/gce_setup.html">Google Compute Engine</a></li>
                
                <li class=""><a href="/setup/aws.html">AWS</a></li>
                
                <li class=""><a href="/setup/jobmanager_high_availability.html">High Availability</a></li>
                
              </ul>
            </li>

            <!-- Programming Guides -->
            <li class="dropdown">
              <a href="/apis" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Programming Guides <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                
                
                <li class=""><a href="/apis/common/index.html"><strong>Basic API Concepts</strong></a></li>
                
                <li class=""><a href="/apis/streaming/index.html"><strong>Streaming Guide</strong> (DataStream API)</a></li>
                
                <li class=""><a href="/apis/batch/index.html"><strong>Batch Guide</strong> (DataSet API)</a></li>
                
                <li class=""><a href="/apis/best_practices.html">Best Practices</a></li>
                
                <li class=""><a href="/apis/table.html">Table API and SQL</a></li>
                
                <li class=""><a href="/apis/cli.html">Command-Line Interface</a></li>
                
                <li class=""><a href="/apis/local_execution.html">Local Execution</a></li>
                
                <li class=""><a href="/apis/cluster_execution.html">Cluster Execution</a></li>
                
                <li class=""><a href="/apis/scala_shell.html">Scala Shell</a></li>
                
                <li class=""><a href="/apis/scala_api_extensions.html">Scala API Extensions</a></li>
                
                <li class=""><a href="/apis/java8.html">Java 8</a></li>
                
              </ul>
            </li>

            <!-- Libraries -->
            <li class="dropdown active">
              <a href="/libs" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Libraries <span class="caret"></span></a>
                <ul class="dropdown-menu" role="menu">
                  
                  
                  <li class="active"><a href="/apis/batch/libs/gelly.html">Graphs: Gelly</a></li>
                  
                  <li class=""><a href="/apis/streaming/libs/cep.html">CEP</a></li>
                  
                  <li class=""><a href="/apis/batch/libs/ml/index.html">Machine Learning</a></li>
                  
              </ul>
            </li>

            <!-- Internals -->
            <li class="dropdown">
              <a href="/internals" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Internals <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                <li role="presentation" class="dropdown-header"><strong>Contribute</strong></li>
                <li><a href="http://flink.apache.org/how-to-contribute.html"><small><span class="glyphicon glyphicon-new-window"></span></small> How to Contribute</a></li>
                <li><a href="http://flink.apache.org/contribute-code.html#coding-guidelines"><small><span class="glyphicon glyphicon-new-window"></span></small> Coding Guidelines</a></li>
                
                
                <li class=""><a href="/internals/ide_setup.html">IDE Setup</a></li>
                
                <li class=""><a href="/internals/logging.html">Logging</a></li>
                
                <li class=""><a href="/internals/general_arch.html">Architecture and Process Model</a></li>
                
                <li class=""><a href="/internals/stream_checkpointing.html">Fault Tolerance for Data Streaming</a></li>
                
                <li class=""><a href="/internals/types_serialization.html">Type Extraction and Serialization</a></li>
                
                <li class=""><a href="/internals/monitoring_rest_api.html">Monitoring REST API</a></li>
                
                <li class=""><a href="/internals/job_scheduling.html">Jobs and Scheduling</a></li>
                
                <li class=""><a href="/internals/add_operator.html">How-To: Add an Operator</a></li>
                
                <li class=""><a href="/internals/back_pressure_monitoring.html">Back Pressure Monitoring</a></li>
                
              </ul>
            </li>
          </ul>
          <form class="navbar-form navbar-right hidden-sm hidden-md" role="search" action="/search-results.html">
            <div class="form-group">
              <input type="text" class="form-control" size="16px" name="q" placeholder="Search all pages">
            </div>
            <button type="submit" class="btn btn-default">Search</button>
          </form>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container -->
    </nav>


    

    <!-- Main content. -->
    <div class="container">
      
      
<div class="row">


  <!-- Sub Navigation -->
  <div class="col-sm-3">
    <ul id="sub-nav">
      
      
      
        
        
        
        <li><a href="/apis/batch/index.html" class="">DataSet API</a>
          
          <ul>
            
              <li><a href="/apis/batch/dataset_transformations.html" class="">Transformations</a></li>
            
              <li><a href="/apis/batch/zip_elements_guide.html" class="">Zipping Elements</a></li>
            
          </ul>
          
        </li>
      
        
        
        
        <li><a href="/apis/batch/fault_tolerance.html" class="">Fault Tolerance</a>
          
        </li>
      
        
        
        
        <li><a href="/apis/batch/iterations.html" class="">Iterations</a>
          
        </li>
      
        
        
        
        <li><a href="/apis/batch/connectors.html" class="">Connectors</a>
          
        </li>
      
        
        
        
        <li><a href="/apis/batch/python.html" class="">Python API</a>
          
        </li>
      
        
        
        
        <li><a href="/apis/batch/examples.html" class="">Examples</a>
          
        </li>
      
        
        
        
        <li><a href="/apis/batch/libs/index.html" class="">Libraries</a>
          
          <ul>
            
              <li><a href="/apis/batch/libs/gelly.html" class="active">Gelly</a></li>
            
              <li><a href="/apis/batch/libs/ml/index.html" class="">Machine Learning</a></li>
            
          </ul>
          
        </li>
      
        
        
        
        <li><a href="/apis/batch/hadoop_compatibility.html" class="">Hadoop Compatibility</a>
          
        </li>
      
    </ul>
  </div>
  <!-- Main -->
  <div class="col-sm-9">
    <!-- Top anchor -->
    <a href="#top"></a>

    <!-- Artifact name change warning. Remove for the 1.0 release. -->
    <div class="panel panel-default">
      <div class="panel-body"><strong>Important</strong>: Maven artifacts which depend on Scala are now suffixed with the Scala major version, e.g. "2.10" or "2.11". Please consult the <a href="https://cwiki.apache.org/confluence/display/FLINK/Maven+artifact+names+suffixed+with+Scala+version">migration guide on the project Wiki</a>.</div>
    </div>

    <!-- Breadcrumbs above the main heading -->
    <ol class="breadcrumb">
      
      
      <li><a href="/apis/batch/index.html">Batch Guide</a></li>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      
      
      

      

      <li><a href="/apis/batch/libs/index.html">Libraries</a></li>
      
      
      <li class="active">Gelly</li>
    </ol>

    <div class="text">
      <!-- Main heading -->
      <h1>Gelly: Flink Graph API</h1>

      <!-- Content -->
      

<p>Gelly is a Graph API for Flink. It contains a set of methods and utilities which aim to simplify the development of graph analysis applications in Flink. In Gelly, graphs can be transformed and modified using high-level functions similar to the ones provided by the batch processing API. Gelly provides methods to create, transform and modify graphs, as well as a library of graph algorithms.</p>

<ul id="markdown-toc">
  <li><a href="#using-gelly" id="markdown-toc-using-gelly">Using Gelly</a></li>
  <li><a href="#graph-representation" id="markdown-toc-graph-representation">Graph Representation</a></li>
  <li><a href="#graph-creation" id="markdown-toc-graph-creation">Graph Creation</a></li>
  <li><a href="#graph-properties" id="markdown-toc-graph-properties">Graph Properties</a></li>
  <li><a href="#graph-transformations" id="markdown-toc-graph-transformations">Graph Transformations</a></li>
  <li><a href="#graph-mutations" id="markdown-toc-graph-mutations">Graph Mutations</a></li>
  <li><a href="#neighborhood-methods" id="markdown-toc-neighborhood-methods">Neighborhood Methods</a></li>
  <li><a href="#iterative-graph-processing" id="markdown-toc-iterative-graph-processing">Iterative Graph Processing</a>    <ul>
      <li><a href="#vertex-centric-iterations" id="markdown-toc-vertex-centric-iterations">Vertex-Centric Iterations</a></li>
      <li><a href="#configuring-a-vertex-centric-iteration" id="markdown-toc-configuring-a-vertex-centric-iteration">Configuring a Vertex-Centric Iteration</a></li>
      <li><a href="#scatter-gather-iterations" id="markdown-toc-scatter-gather-iterations">Scatter-Gather Iterations</a></li>
      <li><a href="#configuring-a-scatter-gather-iteration" id="markdown-toc-configuring-a-scatter-gather-iteration">Configuring a Scatter-Gather Iteration</a></li>
      <li><a href="#gather-sum-apply-iterations" id="markdown-toc-gather-sum-apply-iterations">Gather-Sum-Apply Iterations</a></li>
      <li><a href="#configuring-a-gather-sum-apply-iteration" id="markdown-toc-configuring-a-gather-sum-apply-iteration">Configuring a Gather-Sum-Apply Iteration</a></li>
      <li><a href="#iteration-abstractions-comparison" id="markdown-toc-iteration-abstractions-comparison">Iteration Abstractions Comparison</a></li>
    </ul>
  </li>
  <li><a href="#graph-validation" id="markdown-toc-graph-validation">Graph Validation</a></li>
  <li><a href="#library-methods" id="markdown-toc-library-methods">Library Methods</a>    <ul>
      <li><a href="#community-detection" id="markdown-toc-community-detection">Community Detection</a></li>
      <li><a href="#label-propagation" id="markdown-toc-label-propagation">Label Propagation</a></li>
      <li><a href="#connected-components" id="markdown-toc-connected-components">Connected Components</a></li>
      <li><a href="#gsa-connected-components" id="markdown-toc-gsa-connected-components">GSA Connected Components</a></li>
      <li><a href="#pagerank" id="markdown-toc-pagerank">PageRank</a></li>
      <li><a href="#gsa-pagerank" id="markdown-toc-gsa-pagerank">GSA PageRank</a></li>
      <li><a href="#single-source-shortest-paths" id="markdown-toc-single-source-shortest-paths">Single Source Shortest Paths</a></li>
      <li><a href="#gsa-single-source-shortest-paths" id="markdown-toc-gsa-single-source-shortest-paths">GSA Single Source Shortest Paths</a></li>
      <li><a href="#gsa-triangle-count" id="markdown-toc-gsa-triangle-count">GSA Triangle Count</a></li>
      <li><a href="#triangle-enumerator" id="markdown-toc-triangle-enumerator">Triangle Enumerator</a></li>
      <li><a href="#summarization" id="markdown-toc-summarization">Summarization</a></li>
      <li><a href="#jaccard-index" id="markdown-toc-jaccard-index">Jaccard Index</a></li>
      <li><a href="#local-clustering-coefficient" id="markdown-toc-local-clustering-coefficient">Local Clustering Coefficient</a></li>
    </ul>
  </li>
  <li><a href="#graph-algorithms" id="markdown-toc-graph-algorithms">Graph Algorithms</a></li>
  <li><a href="#graph-generators" id="markdown-toc-graph-generators">Graph Generators</a>    <ul>
      <li><a href="#provided-graph-generators" id="markdown-toc-provided-graph-generators">Provided graph generators</a></li>
      <li><a href="#complete-graph" id="markdown-toc-complete-graph">Complete Graph</a></li>
      <li><a href="#cycle-graph" id="markdown-toc-cycle-graph">Cycle Graph</a></li>
      <li><a href="#empty-graph" id="markdown-toc-empty-graph">Empty Graph</a></li>
      <li><a href="#grid-graph" id="markdown-toc-grid-graph">Grid Graph</a></li>
      <li><a href="#hypercube-graph" id="markdown-toc-hypercube-graph">Hypercube Graph</a></li>
      <li><a href="#path-graph" id="markdown-toc-path-graph">Path Graph</a></li>
      <li><a href="#rmat-graph" id="markdown-toc-rmat-graph">RMat Graph</a></li>
      <li><a href="#singleton-edge-graph" id="markdown-toc-singleton-edge-graph">Singleton Edge Graph</a></li>
      <li><a href="#star-graph" id="markdown-toc-star-graph">Star Graph</a></li>
    </ul>
  </li>
</ul>

<h2 id="using-gelly">Using Gelly</h2>

<p>Gelly is currently part of the <em>libraries</em> Maven project. All relevant classes are located in the <em>org.apache.flink.graph</em> package.</p>

<p>Add the following dependency to your <code>pom.xml</code> to use Gelly.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.apache.flink<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>flink-gelly_2.10<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.1-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span></code></pre></div>

  </div>
  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.apache.flink<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>flink-gelly-scala_2.10<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.1-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span></code></pre></div>

  </div>
</div>

<p>Note that Gelly is currently not part of the binary distribution. See linking with it for cluster execution <a href="/apis/cluster_execution.html#linking-with-modules-not-contained-in-the-binary-distribution">here</a>.</p>

<p>The remaining sections provide a description of available methods and present several examples of how to use Gelly and how to mix it with the Flink DataSet API. After reading this guide, you might also want to check the <a href="https://github.com/apache/flink/blob/master//flink-libraries/flink-gelly-examples/">Gelly examples</a>.</p>

<h2 id="graph-representation">Graph Representation</h2>

<p>In Gelly, a <code>Graph</code> is represented by a <code>DataSet</code> of vertices and a <code>DataSet</code> of edges.</p>

<p>The <code>Graph</code> nodes are represented by the <code>Vertex</code> type. A <code>Vertex</code> is defined by a unique ID and a value. <code>Vertex</code> IDs should implement the <code>Comparable</code> interface. Vertices without value can be represented by setting the value type to <code>NullValue</code>.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// create a new vertex with a Long ID and a String value</span>
<span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;(</span><span class="mi">1L</span><span class="o">,</span> <span class="s">&quot;foo&quot;</span><span class="o">);</span>

<span class="c1">// create a new vertex with a Long ID and no value</span>
<span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">NullValue</span><span class="o">&gt;(</span><span class="mi">1L</span><span class="o">,</span> <span class="n">NullValue</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// create a new vertex with a Long ID and a String value</span>
<span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Vertex</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="s">&quot;foo&quot;</span><span class="o">)</span>

<span class="c1">// create a new vertex with a Long ID and no value</span>
<span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Vertex</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="nc">NullValue</span><span class="o">.</span><span class="n">getInstance</span><span class="o">())</span></code></pre></div>

  </div>
</div>

<p>The graph edges are represented by the <code>Edge</code> type. An <code>Edge</code> is defined by a source ID (the ID of the source <code>Vertex</code>), a target ID (the ID of the target <code>Vertex</code>) and an optional value. The source and target IDs should be of the same type as the <code>Vertex</code> IDs. Edges with no value have a <code>NullValue</code> value type.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Edge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Edge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;(</span><span class="mi">1L</span><span class="o">,</span> <span class="mi">2L</span><span class="o">,</span> <span class="mf">0.5</span><span class="o">);</span>

<span class="c1">// reverse the source and target of this edge</span>
<span class="n">Edge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">reversed</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">reverse</span><span class="o">();</span>

<span class="n">Double</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span> <span class="c1">// weight = 0.5</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">e</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="mi">2L</span><span class="o">,</span> <span class="mf">0.5</span><span class="o">)</span>

<span class="c1">// reverse the source and target of this edge</span>
<span class="k">val</span> <span class="n">reversed</span> <span class="k">=</span> <span class="n">e</span><span class="o">.</span><span class="n">reverse</span>

<span class="k">val</span> <span class="n">weight</span> <span class="k">=</span> <span class="n">e</span><span class="o">.</span><span class="n">getValue</span> <span class="c1">// weight = 0.5</span></code></pre></div>

  </div>
</div>

<p>In Gelly an <code>Edge</code> is always directed from the source vertex to the target vertex. A <code>Graph</code> may be undirected if for
every <code>Edge</code> it contains a matching <code>Edge</code> from the target vertex to the source vertex.</p>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="graph-creation">Graph Creation</h2>

<p>You can create a <code>Graph</code> in the following ways:</p>

<ul>
  <li>from a <code>DataSet</code> of edges and an optional <code>DataSet</code> of vertices:</li>
</ul>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">vertices</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">edges</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="na">fromDataSet</span><span class="o">(</span><span class="n">vertices</span><span class="o">,</span> <span class="n">edges</span><span class="o">,</span> <span class="n">env</span><span class="o">);</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">vertices</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Vertex</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">edges</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Edge</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Double</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">.</span><span class="n">fromDataSet</span><span class="o">(</span><span class="n">vertices</span><span class="o">,</span> <span class="n">edges</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span></code></pre></div>

  </div>
</div>

<ul>
  <li>from a <code>DataSet</code> of <code>Tuple2</code> representing the edges. Gelly will convert each <code>Tuple2</code> to an <code>Edge</code>, where the first field will be the source ID and the second field will be the target ID. Both vertex and edge values will be set to <code>NullValue</code>.</li>
</ul>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">edges</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">NullValue</span><span class="o">,</span> <span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="na">fromTuple2DataSet</span><span class="o">(</span><span class="n">edges</span><span class="o">,</span> <span class="n">env</span><span class="o">);</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">edges</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">.</span><span class="n">fromTuple2DataSet</span><span class="o">(</span><span class="n">edges</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span></code></pre></div>

  </div>
</div>

<ul>
  <li>from a <code>DataSet</code> of <code>Tuple3</code> and an optional <code>DataSet</code> of <code>Tuple2</code>. In this case, Gelly will convert each <code>Tuple3</code> to an <code>Edge</code>, where the first field will be the source ID, the second field will be the target ID and the third field will be the edge value. Equivalently, each <code>Tuple2</code> will be converted to a <code>Vertex</code>, where the first field will be the vertex ID and the second field will be the vertex value:</li>
</ul>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">vertexTuples</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">readCsvFile</span><span class="o">(</span><span class="s">&quot;path/to/vertex/input&quot;</span><span class="o">);</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">edgeTuples</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">readCsvFile</span><span class="o">(</span><span class="s">&quot;path/to/edge/input&quot;</span><span class="o">);</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="na">fromTupleDataSet</span><span class="o">(</span><span class="n">vertexTuples</span><span class="o">,</span> <span class="n">edgeTuples</span><span class="o">,</span> <span class="n">env</span><span class="o">);</span></code></pre></div>

    <ul>
      <li>
        <p>from a CSV file of Edge data and an optional CSV file of Vertex data. In this case, Gelly will convert each row from the Edge CSV file to an <code>Edge</code>, where the first field will be the source ID, the second field will be the target ID and the third field (if present) will be the edge value. Equivalently, each row from the optional Vertex CSV file will be converted to a <code>Vertex</code>, where the first field will be the vertex ID and the second field (if present) will be the vertex value. In order to get a <code>Graph</code> from a <code>GraphCsvReader</code> one has to specify the types, using one of the following methods:</p>
      </li>
      <li><code>types(Class&lt;K&gt; vertexKey, Class&lt;VV&gt; vertexValue,Class&lt;EV&gt; edgeValue)</code>: both vertex and edge values are present.</li>
      <li><code>edgeTypes(Class&lt;K&gt; vertexKey, Class&lt;EV&gt; edgeValue)</code>: the Graph has edge values, but no vertex values.</li>
      <li><code>vertexTypes(Class&lt;K&gt; vertexKey, Class&lt;VV&gt; vertexValue)</code>: the Graph has vertex values, but no edge values.</li>
      <li><code>keyType(Class&lt;K&gt; vertexKey)</code>: the Graph has no vertex values and no edge values.</li>
    </ul>

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="c1">// create a Graph with String Vertex IDs, Long Vertex values and Double Edge values</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="na">fromCsvReader</span><span class="o">(</span><span class="s">&quot;path/to/vertex/input&quot;</span><span class="o">,</span> <span class="s">&quot;path/to/edge/input&quot;</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span>
					<span class="o">.</span><span class="na">types</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Long</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Double</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>


<span class="c1">// create a Graph with neither Vertex nor Edge values</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">NullValue</span><span class="o">,</span> <span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">simpleGraph</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="na">fromCsvReader</span><span class="o">(</span><span class="s">&quot;path/to/edge/input&quot;</span><span class="o">,</span> <span class="n">env</span><span class="o">).</span><span class="na">keyType</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">class</span><span class="o">);</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">vertexTuples</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readCsvFile</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">](</span><span class="s">&quot;path/to/vertex/input&quot;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">edgeTuples</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readCsvFile</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">](</span><span class="s">&quot;path/to/edge/input&quot;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">.</span><span class="n">fromTupleDataSet</span><span class="o">(</span><span class="n">vertexTuples</span><span class="o">,</span> <span class="n">edgeTuples</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span></code></pre></div>

    <ul>
      <li>from a CSV file of Edge data and an optional CSV file of Vertex data.
In this case, Gelly will convert each row from the Edge CSV file to an <code>Edge</code>.
The first field of the each row will be the source ID, the second field will be the target ID and the third field (if present) will be the edge value.
If the edges have no associated value, set the edge value type parameter (3rd type argument) to <code>NullValue</code>.
You can also specify that the vertices are initialized with a vertex value.
If you provide a path to a CSV file via <code>pathVertices</code>, each row of this file will be converted to a <code>Vertex</code>.
The first field of each row will be the vertex ID and the second field will be the vertex value.
If you provide a vertex value initializer <code>MapFunction</code> via the <code>vertexValueInitializer</code> parameter, then this function is used to generate the vertex values.
The set of vertices will be created automatically from the edges input.
If the vertices have no associated value, set the vertex value type parameter (2nd type argument) to <code>NullValue</code>.
The vertices will then be automatically created from the edges input with vertex value of type <code>NullValue</code>.</li>
    </ul>

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="c1">// create a Graph with String Vertex IDs, Long Vertex values and Double Edge values</span>
<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">.</span><span class="n">fromCsvReader</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Long</span>, <span class="kt">Double</span><span class="o">](</span>
		<span class="n">pathVertices</span> <span class="k">=</span> <span class="s">&quot;path/to/vertex/input&quot;</span><span class="o">,</span>
		<span class="n">pathEdges</span> <span class="k">=</span> <span class="s">&quot;path/to/edge/input&quot;</span><span class="o">,</span>
		<span class="n">env</span> <span class="k">=</span> <span class="n">env</span><span class="o">)</span>


<span class="c1">// create a Graph with neither Vertex nor Edge values</span>
<span class="k">val</span> <span class="n">simpleGraph</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">.</span><span class="n">fromCsvReader</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">NullValue</span>, <span class="kt">NullValue</span><span class="o">](</span>
		<span class="n">pathEdges</span> <span class="k">=</span> <span class="s">&quot;path/to/edge/input&quot;</span><span class="o">,</span>
		<span class="n">env</span> <span class="k">=</span> <span class="n">env</span><span class="o">)</span>

<span class="c1">// create a Graph with Double Vertex values generated by a vertex value initializer and no Edge values</span>
<span class="k">val</span> <span class="n">simpleGraph</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">.</span><span class="n">fromCsvReader</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span>, <span class="kt">NullValue</span><span class="o">](</span>
        <span class="n">pathEdges</span> <span class="k">=</span> <span class="s">&quot;path/to/edge/input&quot;</span><span class="o">,</span>
        <span class="n">vertexValueInitializer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MapFunction</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span><span class="o">]()</span> <span class="o">{</span>
            <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
                <span class="n">id</span><span class="o">.</span><span class="n">toDouble</span>
            <span class="o">}</span>
        <span class="o">},</span>
        <span class="n">env</span> <span class="k">=</span> <span class="n">env</span><span class="o">)</span></code></pre></div>

  </div>
</div>

<ul>
  <li>from a <code>Collection</code> of edges and an optional <code>Collection</code> of vertices:</li>
</ul>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">vertexList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">...</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">edgeList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">...</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="na">fromCollection</span><span class="o">(</span><span class="n">vertexList</span><span class="o">,</span> <span class="n">edgeList</span><span class="o">,</span> <span class="n">env</span><span class="o">);</span></code></pre></div>

    <p>If no vertex input is provided during Graph creation, Gelly will automatically produce the <code>Vertex</code> <code>DataSet</code> from the edge input. In this case, the created vertices will have no values. Alternatively, you can provide a <code>MapFunction</code> as an argument to the creation method, in order to initialize the <code>Vertex</code> values:</p>

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="c1">// initialize the vertex value to be equal to the vertex ID</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="na">fromCollection</span><span class="o">(</span><span class="n">edgeList</span><span class="o">,</span>
				<span class="k">new</span> <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
					<span class="kd">public</span> <span class="n">Long</span> <span class="nf">map</span><span class="o">(</span><span class="n">Long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
						<span class="k">return</span> <span class="n">value</span><span class="o">;</span>
					<span class="o">}</span>
				<span class="o">},</span> <span class="n">env</span><span class="o">);</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">vertexList</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(...)</span>

<span class="k">val</span> <span class="n">edgeList</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(...)</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">vertexList</span><span class="o">,</span> <span class="n">edgeList</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span></code></pre></div>

    <p>If no vertex input is provided during Graph creation, Gelly will automatically produce the <code>Vertex</code> <code>DataSet</code> from the edge input. In this case, the created vertices will have no values. Alternatively, you can provide a <code>MapFunction</code> as an argument to the creation method, in order to initialize the <code>Vertex</code> values:</p>

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">val</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span>

<span class="c1">// initialize the vertex value to be equal to the vertex ID</span>
<span class="n">val</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="na">fromCollection</span><span class="o">(</span><span class="n">edgeList</span><span class="o">,</span>
    <span class="k">new</span> <span class="n">MapFunction</span><span class="o">[</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">]</span> <span class="o">{</span>
       <span class="n">def</span> <span class="nf">map</span><span class="o">(</span><span class="nl">id:</span> <span class="n">Long</span><span class="o">):</span> <span class="n">Long</span> <span class="o">=</span> <span class="n">id</span>
    <span class="o">},</span> <span class="n">env</span><span class="o">)</span></code></pre></div>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="graph-properties">Graph Properties</h2>

<p>Gelly includes the following methods for retrieving various Graph properties and metrics:</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// get the Vertex DataSet</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">&gt;&gt;</span> <span class="nf">getVertices</span><span class="o">()</span>

<span class="c1">// get the Edge DataSet</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">EV</span><span class="o">&gt;&gt;</span> <span class="nf">getEdges</span><span class="o">()</span>

<span class="c1">// get the IDs of the vertices as a DataSet</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="nf">getVertexIds</span><span class="o">()</span>

<span class="c1">// get the source-target pairs of the edge IDs as a DataSet</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">K</span><span class="o">&gt;&gt;</span> <span class="nf">getEdgeIds</span><span class="o">()</span>

<span class="c1">// get a DataSet of &lt;vertex ID, in-degree&gt; pairs for all vertices</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="nf">inDegrees</span><span class="o">()</span>

<span class="c1">// get a DataSet of &lt;vertex ID, out-degree&gt; pairs for all vertices</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="nf">outDegrees</span><span class="o">()</span>

<span class="c1">// get a DataSet of &lt;vertex ID, degree&gt; pairs for all vertices, where degree is the sum of in- and out- degrees</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="nf">getDegrees</span><span class="o">()</span>

<span class="c1">// get the number of vertices</span>
<span class="kt">long</span> <span class="nf">numberOfVertices</span><span class="o">()</span>

<span class="c1">// get the number of edges</span>
<span class="kt">long</span> <span class="nf">numberOfEdges</span><span class="o">()</span>

<span class="c1">// get a DataSet of Triplets&lt;srcVertex, trgVertex, edge&gt;</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Triplet</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">,</span> <span class="n">EV</span><span class="o">&gt;&gt;</span> <span class="nf">getTriplets</span><span class="o">()</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// get the Vertex DataSet</span>
<span class="n">getVertices</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Vertex</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">VV</span><span class="o">]]</span>

<span class="c1">// get the Edge DataSet</span>
<span class="n">getEdges</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Edge</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">EV</span><span class="o">]]</span>

<span class="c1">// get the IDs of the vertices as a DataSet</span>
<span class="n">getVertexIds</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">K</span><span class="o">]</span>

<span class="c1">// get the source-target pairs of the edge IDs as a DataSet</span>
<span class="n">getEdgeIds</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">K</span><span class="o">)]</span>

<span class="c1">// get a DataSet of &lt;vertex ID, in-degree&gt; pairs for all vertices</span>
<span class="n">inDegrees</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">Long</span><span class="o">)]</span>

<span class="c1">// get a DataSet of &lt;vertex ID, out-degree&gt; pairs for all vertices</span>
<span class="n">outDegrees</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">Long</span><span class="o">)]</span>

<span class="c1">// get a DataSet of &lt;vertex ID, degree&gt; pairs for all vertices, where degree is the sum of in- and out- degrees</span>
<span class="n">getDegrees</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">Long</span><span class="o">)]</span>

<span class="c1">// get the number of vertices</span>
<span class="n">numberOfVertices</span><span class="k">:</span> <span class="kt">Long</span>

<span class="c1">// get the number of edges</span>
<span class="n">numberOfEdges</span><span class="k">:</span> <span class="kt">Long</span>

<span class="c1">// get a DataSet of Triplets&lt;srcVertex, trgVertex, edge&gt;</span>
<span class="n">getTriplets</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Triplet</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">VV</span>, <span class="kt">EV</span><span class="o">]]</span></code></pre></div>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="graph-transformations">Graph Transformations</h2>

<ul>
  <li><strong>Map</strong>: Gelly provides specialized methods for applying a map transformation on the vertex values or edge values. <code>mapVertices</code> and <code>mapEdges</code> return a new <code>Graph</code>, where the IDs of the vertices (or edges) remain unchanged, while the values are transformed according to the provided user-defined map function. The map functions also allow changing the type of the vertex or edge values.</li>
</ul>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="na">fromDataSet</span><span class="o">(</span><span class="n">vertices</span><span class="o">,</span> <span class="n">edges</span><span class="o">,</span> <span class="n">env</span><span class="o">);</span>

<span class="c1">// increment each vertex value by one</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">updatedGraph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">mapVertices</span><span class="o">(</span>
				<span class="k">new</span> <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
					<span class="kd">public</span> <span class="n">Long</span> <span class="nf">map</span><span class="o">(</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
						<span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
					<span class="o">}</span>
				<span class="o">});</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>
<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">.</span><span class="n">fromDataSet</span><span class="o">(</span><span class="n">vertices</span><span class="o">,</span> <span class="n">edges</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span>

<span class="c1">// increment each vertex value by one</span>
<span class="k">val</span> <span class="n">updatedGraph</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">mapVertices</span><span class="o">(</span><span class="n">v</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">getValue</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span></code></pre></div>

  </div>
</div>

<ul>
  <li><strong>Translate</strong>: Gelly provides specialized methods for translating the value and/or type of vertex and edge IDs (<code>translateGraphIDs</code>), vertex values (<code>translateVertexValues</code>), or edge values (<code>translateEdgeValues</code>). Translation is performed by the user-defined map function, several of which are provided in the <code>org.apache.flink.graph.asm.translate</code> package. The same <code>MapFunction</code> can be used for all the three translate methods.</li>
</ul>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="na">fromDataSet</span><span class="o">(</span><span class="n">vertices</span><span class="o">,</span> <span class="n">edges</span><span class="o">,</span> <span class="n">env</span><span class="o">);</span>

<span class="c1">// translate each vertex and edge ID to a String</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">updatedGraph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">translateGraphIds</span><span class="o">(</span>
				<span class="k">new</span> <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
					<span class="kd">public</span> <span class="n">String</span> <span class="nf">map</span><span class="o">(</span><span class="n">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
						<span class="k">return</span> <span class="n">id</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
					<span class="o">}</span>
				<span class="o">});</span>

<span class="c1">// translate vertex IDs, edge IDs, vertex values, and edge values to LongValue</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">LongValue</span><span class="o">,</span> <span class="n">LongValue</span><span class="o">,</span> <span class="n">LongValue</span><span class="o">&gt;</span> <span class="n">updatedGraph</span> <span class="o">=</span> <span class="n">graph</span>
                <span class="o">.</span><span class="na">translateGraphIds</span><span class="o">(</span><span class="k">new</span> <span class="nf">LongToLongValue</span><span class="o">())</span>
                <span class="o">.</span><span class="na">translateVertexValues</span><span class="o">(</span><span class="k">new</span> <span class="nf">LongToLongValue</span><span class="o">())</span>
                <span class="o">.</span><span class="na">translateEdgeValues</span><span class="o">(</span><span class="k">new</span> <span class="nf">LongToLongValue</span><span class="o">())</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>
<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">.</span><span class="n">fromDataSet</span><span class="o">(</span><span class="n">vertices</span><span class="o">,</span> <span class="n">edges</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span>

<span class="c1">// translate each vertex and edge ID to a String</span>
<span class="k">val</span> <span class="n">updatedGraph</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">translateGraphIds</span><span class="o">(</span><span class="n">id</span> <span class="k">=&gt;</span> <span class="n">id</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span></code></pre></div>

  </div>
</div>

<ul>
  <li><strong>Filter</strong>: A filter transformation applies a user-defined filter function on the vertices or edges of the <code>Graph</code>. <code>filterOnEdges</code> will create a sub-graph of the original graph, keeping only the edges that satisfy the provided predicate. Note that the vertex dataset will not be modified. Respectively, <code>filterOnVertices</code> applies a filter on the vertices of the graph. Edges whose source and/or target do not satisfy the vertex predicate are removed from the resulting edge dataset. The <code>subgraph</code> method can be used to apply a filter function to the vertices and the edges at the same time.</li>
</ul>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">graph</span><span class="o">.</span><span class="na">subgraph</span><span class="o">(</span>
		<span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;()</span> <span class="o">{</span>
			   	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">vertex</span><span class="o">)</span> <span class="o">{</span>
					<span class="c1">// keep only vertices with positive values</span>
					<span class="k">return</span> <span class="o">(</span><span class="n">vertex</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span>
			   <span class="o">}</span>
		   <span class="o">},</span>
		<span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;()</span> <span class="o">{</span>
				<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">edge</span><span class="o">)</span> <span class="o">{</span>
					<span class="c1">// keep only edges with negative values</span>
					<span class="k">return</span> <span class="o">(</span><span class="n">edge</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">);</span>
				<span class="o">}</span>
		<span class="o">})</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span>, <span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// keep only vertices with positive values</span>
<span class="c1">// and only edges with negative values</span>
<span class="n">graph</span><span class="o">.</span><span class="n">subgraph</span><span class="o">((</span><span class="n">vertex</span> <span class="k">=&gt;</span> <span class="n">vertex</span><span class="o">.</span><span class="n">getValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="n">edge</span> <span class="k">=&gt;</span> <span class="n">edge</span><span class="o">.</span><span class="n">getValue</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">))</span></code></pre></div>

  </div>
</div>

<p class="text-center">
    <img alt="Filter Transformations" width="80%" src="fig/gelly-filter.png" />
</p>

<ul>
  <li><strong>Join</strong>: Gelly provides specialized methods for joining the vertex and edge datasets with other input datasets. <code>joinWithVertices</code> joins the vertices with a <code>Tuple2</code> input data set. The join is performed using the vertex ID and the first field of the <code>Tuple2</code> input as the join keys. The method returns a new <code>Graph</code> where the vertex values have been updated according to a provided user-defined transformation function.
Similarly, an input dataset can be joined with the edges, using one of three methods. <code>joinWithEdges</code> expects an input <code>DataSet</code> of <code>Tuple3</code> and joins on the composite key of both source and target vertex IDs. <code>joinWithEdgesOnSource</code> expects a <code>DataSet</code> of <code>Tuple2</code> and joins on the source key of the edges and the first attribute of the input dataset and <code>joinWithEdgesOnTarget</code> expects a <code>DataSet</code> of <code>Tuple2</code> and joins on the target key of the edges and the first attribute of the input dataset. All three methods apply a transformation function on the edge and the input data set values.
Note that if the input dataset contains a key multiple times, all Gelly join methods will only consider the first value encountered.</li>
</ul>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">network</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">vertexOutDegrees</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="na">outDegrees</span><span class="o">();</span>

<span class="c1">// assign the transition probabilities as the edge weights</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">networkWithWeights</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="na">joinWithEdgesOnSource</span><span class="o">(</span><span class="n">vertexOutDegrees</span><span class="o">,</span>
				<span class="k">new</span> <span class="n">VertexJoinFunction</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
					<span class="kd">public</span> <span class="n">Double</span> <span class="nf">vertexJoin</span><span class="o">(</span><span class="n">Double</span> <span class="n">vertexValue</span><span class="o">,</span> <span class="n">Long</span> <span class="n">inputValue</span><span class="o">)</span> <span class="o">{</span>
						<span class="k">return</span> <span class="n">vertexValue</span> <span class="o">/</span> <span class="n">inputValue</span><span class="o">;</span>
					<span class="o">}</span>
				<span class="o">});</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">network</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">vertexOutDegrees</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">)]</span> <span class="k">=</span> <span class="n">network</span><span class="o">.</span><span class="n">outDegrees</span>

<span class="c1">// assign the transition probabilities as the edge weights</span>
<span class="k">val</span> <span class="n">networkWithWeights</span> <span class="k">=</span> <span class="n">network</span><span class="o">.</span><span class="n">joinWithEdgesOnSource</span><span class="o">(</span><span class="n">vertexOutDegrees</span><span class="o">,</span> <span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">v2</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">v1</span> <span class="o">/</span> <span class="n">v2</span><span class="o">)</span></code></pre></div>

  </div>
</div>

<ul>
  <li>
    <p><strong>Reverse</strong>: the <code>reverse()</code> method returns a new <code>Graph</code> where the direction of all edges has been reversed.</p>
  </li>
  <li>
    <p><strong>Undirected</strong>: In Gelly, a <code>Graph</code> is always directed. Undirected graphs can be represented by adding all opposite-direction edges to a graph. For this purpose, Gelly provides the <code>getUndirected()</code> method.</p>
  </li>
  <li>
    <p><strong>Union</strong>: Gelly’s <code>union()</code> method performs a union operation on the vertex and edge sets of the specified graph and the current graph. Duplicate vertices are removed from the resulting <code>Graph</code>, while if duplicate edges exist, these will be preserved.</p>
  </li>
</ul>

<p class="text-center">
    <img alt="Union Transformation" width="50%" src="fig/gelly-union.png" />
</p>

<ul>
  <li>
    <p><strong>Difference</strong>: Gelly’s <code>difference()</code> method performs a difference on the vertex and edge sets of the current graph and the specified graph.</p>
  </li>
  <li>
    <p><strong>Intersect</strong>: Gelly’s <code>intersect()</code> method performs an intersect on the edge
 sets of the current graph and the specified graph. The result is a new <code>Graph</code> that contains all
 edges that exist in both input graphs. Two edges are considered equal, if they have the same source
 identifier, target identifier and edge value. Vertices in the resulting graph have no
 value. If vertex values are required, one can for example retrieve them from one of the input graphs using
 the <code>joinWithVertices()</code> method.
 Depending on the parameter <code>distinct</code>, equal edges are either contained once in the resulting
 <code>Graph</code> or as often as there are pairs of equal edges in the input graphs.</p>
  </li>
</ul>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="c1">// create first graph from edges {(1, 3, 12) (1, 3, 13), (1, 3, 13)}</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">edges1</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">NullValue</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">graph1</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="na">fromCollection</span><span class="o">(</span><span class="n">edges1</span><span class="o">,</span> <span class="n">env</span><span class="o">);</span>

<span class="c1">// create second graph from edges {(1, 3, 13)}</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">edges2</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">NullValue</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">graph2</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="na">fromCollection</span><span class="o">(</span><span class="n">edges2</span><span class="o">,</span> <span class="n">env</span><span class="o">);</span>

<span class="c1">// Using distinct = true results in {(1,3,13)}</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">NullValue</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">intersect1</span> <span class="o">=</span> <span class="n">graph1</span><span class="o">.</span><span class="na">intersect</span><span class="o">(</span><span class="n">graph2</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>

<span class="c1">// Using distinct = false results in {(1,3,13),(1,3,13)} as there is one edge pair</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">NullValue</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">intersect2</span> <span class="o">=</span> <span class="n">graph1</span><span class="o">.</span><span class="na">intersect</span><span class="o">(</span><span class="n">graph2</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="c1">// create first graph from edges {(1, 3, 12) (1, 3, 13), (1, 3, 13)}</span>
<span class="k">val</span> <span class="n">edges1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Edge</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="n">graph1</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">edges1</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span>

<span class="c1">// create second graph from edges {(1, 3, 13)}</span>
<span class="k">val</span> <span class="n">edges2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Edge</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="n">graph2</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">edges2</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span>


<span class="c1">// Using distinct = true results in {(1,3,13)}</span>
<span class="k">val</span> <span class="n">intersect1</span> <span class="k">=</span> <span class="n">graph1</span><span class="o">.</span><span class="n">intersect</span><span class="o">(</span><span class="n">graph2</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>

<span class="c1">// Using distinct = false results in {(1,3,13),(1,3,13)} as there is one edge pair</span>
<span class="k">val</span> <span class="n">intersect2</span> <span class="k">=</span> <span class="n">graph1</span><span class="o">.</span><span class="n">intersect</span><span class="o">(</span><span class="n">graph2</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span></code></pre></div>

  </div>
</div>

<p>-<a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="graph-mutations">Graph Mutations</h2>

<p>Gelly includes the following methods for adding and removing vertices and edges from an input <code>Graph</code>:</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// adds a Vertex to the Graph. If the Vertex already exists, it will not be added again.</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">,</span> <span class="n">EV</span><span class="o">&gt;</span> <span class="nf">addVertex</span><span class="o">(</span><span class="kd">final</span> <span class="n">Vertex</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">&gt;</span> <span class="n">vertex</span><span class="o">)</span>

<span class="c1">// adds a list of vertices to the Graph. If the vertices already exist in the graph, they will not be added once more.</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">,</span> <span class="n">EV</span><span class="o">&gt;</span> <span class="nf">addVertices</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">&gt;&gt;</span> <span class="n">verticesToAdd</span><span class="o">)</span>

<span class="c1">// adds an Edge to the Graph. If the source and target vertices do not exist in the graph, they will also be added.</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">,</span> <span class="n">EV</span><span class="o">&gt;</span> <span class="nf">addEdge</span><span class="o">(</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">&gt;</span> <span class="n">source</span><span class="o">,</span> <span class="n">Vertex</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">&gt;</span> <span class="n">target</span><span class="o">,</span> <span class="n">EV</span> <span class="n">edgeValue</span><span class="o">)</span>

<span class="c1">// adds a list of edges to the Graph. When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">,</span> <span class="n">EV</span><span class="o">&gt;</span> <span class="nf">addEdges</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">EV</span><span class="o">&gt;&gt;</span> <span class="n">newEdges</span><span class="o">)</span>

<span class="c1">// removes the given Vertex and its edges from the Graph.</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">,</span> <span class="n">EV</span><span class="o">&gt;</span> <span class="nf">removeVertex</span><span class="o">(</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">&gt;</span> <span class="n">vertex</span><span class="o">)</span>

<span class="c1">// removes the given list of vertices and their edges from the Graph</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">,</span> <span class="n">EV</span><span class="o">&gt;</span> <span class="nf">removeVertices</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">&gt;&gt;</span> <span class="n">verticesToBeRemoved</span><span class="o">)</span>

<span class="c1">// removes *all* edges that match the given Edge from the Graph.</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">,</span> <span class="n">EV</span><span class="o">&gt;</span> <span class="nf">removeEdge</span><span class="o">(</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">EV</span><span class="o">&gt;</span> <span class="n">edge</span><span class="o">)</span>

<span class="c1">// removes *all* edges that match the edges in the given list</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">VV</span><span class="o">,</span> <span class="n">EV</span><span class="o">&gt;</span> <span class="nf">removeEdges</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">EV</span><span class="o">&gt;&gt;</span> <span class="n">edgesToBeRemoved</span><span class="o">)</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// adds a Vertex to the Graph. If the Vertex already exists, it will not be added again.</span>
<span class="n">addVertex</span><span class="o">(</span><span class="n">vertex</span><span class="k">:</span> <span class="kt">Vertex</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">VV</span><span class="o">])</span>

<span class="c1">// adds a list of vertices to the Graph. If the vertices already exist in the graph, they will not be added once more.</span>
<span class="n">addVertices</span><span class="o">(</span><span class="n">verticesToAdd</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Vertex</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">VV</span><span class="o">]])</span>

<span class="c1">// adds an Edge to the Graph. If the source and target vertices do not exist in the graph, they will also be added.</span>
<span class="n">addEdge</span><span class="o">(</span><span class="n">source</span><span class="k">:</span> <span class="kt">Vertex</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">VV</span><span class="o">],</span> <span class="n">target</span><span class="k">:</span> <span class="kt">Vertex</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">VV</span><span class="o">],</span> <span class="n">edgeValue</span><span class="k">:</span> <span class="kt">EV</span><span class="o">)</span>

<span class="c1">// adds a list of edges to the Graph. When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.</span>
<span class="n">addEdges</span><span class="o">(</span><span class="n">edges</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Edge</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">EV</span><span class="o">]])</span>

<span class="c1">// removes the given Vertex and its edges from the Graph.</span>
<span class="n">removeVertex</span><span class="o">(</span><span class="n">vertex</span><span class="k">:</span> <span class="kt">Vertex</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">VV</span><span class="o">])</span>

<span class="c1">// removes the given list of vertices and their edges from the Graph</span>
<span class="n">removeVertices</span><span class="o">(</span><span class="n">verticesToBeRemoved</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Vertex</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">VV</span><span class="o">]])</span>

<span class="c1">// removes *all* edges that match the given Edge from the Graph.</span>
<span class="n">removeEdge</span><span class="o">(</span><span class="n">edge</span><span class="k">:</span> <span class="kt">Edge</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">EV</span><span class="o">])</span>

<span class="c1">// removes *all* edges that match the edges in the given list</span>
<span class="n">removeEdges</span><span class="o">(</span><span class="n">edgesToBeRemoved</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Edge</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">EV</span><span class="o">]])</span></code></pre></div>

  </div>
</div>

<h2 id="neighborhood-methods">Neighborhood Methods</h2>

<p>Neighborhood methods allow vertices to perform an aggregation on their first-hop neighborhood.
<code>reduceOnEdges()</code> can be used to compute an aggregation on the values of the neighboring edges of a vertex and <code>reduceOnNeighbors()</code> can be used to compute an aggregation on the values of the neighboring vertices. These methods assume associative and commutative aggregations and exploit combiners internally, significantly improving performance.
The neighborhood scope is defined by the <code>EdgeDirection</code> parameter, which takes the values <code>IN</code>, <code>OUT</code> or <code>ALL</code>. <code>IN</code> will gather all in-coming edges (neighbors) of a vertex, <code>OUT</code> will gather all out-going edges (neighbors), while <code>ALL</code> will gather all edges (neighbors).</p>

<p>For example, assume that you want to select the minimum weight of all out-edges for each vertex in the following graph:</p>

<p class="text-center">
    <img alt="reduceOnEdges Example" width="50%" src="fig/gelly-example-graph.png" />
</p>

<p>The following code will collect the out-edges for each vertex and apply the <code>SelectMinWeight()</code> user-defined function on each of the resulting neighborhoods:</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">minWeights</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">reduceOnEdges</span><span class="o">(</span><span class="k">new</span> <span class="nf">SelectMinWeight</span><span class="o">(),</span> <span class="n">EdgeDirection</span><span class="o">.</span><span class="na">OUT</span><span class="o">);</span>

<span class="c1">// user-defined function to select the minimum weight</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">SelectMinWeight</span> <span class="kd">implements</span> <span class="n">ReduceEdgesFunction</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="o">{</span>

		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="n">Double</span> <span class="nf">reduceEdges</span><span class="o">(</span><span class="n">Double</span> <span class="n">firstEdgeValue</span><span class="o">,</span> <span class="n">Double</span> <span class="n">secondEdgeValue</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">firstEdgeValue</span><span class="o">,</span> <span class="n">secondEdgeValue</span><span class="o">);</span>
		<span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">minWeights</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">reduceOnEdges</span><span class="o">(</span><span class="k">new</span> <span class="nc">SelectMinWeight</span><span class="o">,</span> <span class="nc">EdgeDirection</span><span class="o">.</span><span class="nc">OUT</span><span class="o">)</span>

<span class="c1">// user-defined function to select the minimum weight</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">SelectMinWeight</span> <span class="k">extends</span> <span class="nc">ReduceEdgesFunction</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">override</span> <span class="k">def</span> <span class="n">reduceEdges</span><span class="o">(</span><span class="n">firstEdgeValue</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">secondEdgeValue</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
		<span class="nc">Math</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="n">firstEdgeValue</span><span class="o">,</span> <span class="n">secondEdgeValue</span><span class="o">)</span>
	<span class="o">}</span>
 <span class="o">}</span></code></pre></div>

  </div>
</div>

<p class="text-center">
    <img alt="reduceOnEdges Example" width="50%" src="fig/gelly-reduceOnEdges.png" />
</p>

<p>Similarly, assume that you would like to compute the sum of the values of all in-coming neighbors, for every vertex. The following code will collect the in-coming neighbors for each vertex and apply the <code>SumValues()</code> user-defined function on each neighborhood:</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">verticesWithSum</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">reduceOnNeighbors</span><span class="o">(</span><span class="k">new</span> <span class="nf">SumValues</span><span class="o">(),</span> <span class="n">EdgeDirection</span><span class="o">.</span><span class="na">IN</span><span class="o">);</span>

<span class="c1">// user-defined function to sum the neighbor values</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">SumValues</span> <span class="kd">implements</span> <span class="n">ReduceNeighborsFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="o">{</span>

	    	<span class="nd">@Override</span>
	    	<span class="kd">public</span> <span class="n">Long</span> <span class="nf">reduceNeighbors</span><span class="o">(</span><span class="n">Long</span> <span class="n">firstNeighbor</span><span class="o">,</span> <span class="n">Long</span> <span class="n">secondNeighbor</span><span class="o">)</span> <span class="o">{</span>
		    	<span class="k">return</span> <span class="n">firstNeighbor</span> <span class="o">+</span> <span class="n">secondNeighbor</span><span class="o">;</span>
	  	<span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">verticesWithSum</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">reduceOnNeighbors</span><span class="o">(</span><span class="k">new</span> <span class="nc">SumValues</span><span class="o">,</span> <span class="nc">EdgeDirection</span><span class="o">.</span><span class="nc">IN</span><span class="o">)</span>

<span class="c1">// user-defined function to sum the neighbor values</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">SumValues</span> <span class="k">extends</span> <span class="nc">ReduceNeighborsFunction</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="o">{</span>
   	<span class="k">override</span> <span class="k">def</span> <span class="n">reduceNeighbors</span><span class="o">(</span><span class="n">firstNeighbor</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">secondNeighbor</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="o">{</span>
    	<span class="n">firstNeighbor</span> <span class="o">+</span> <span class="n">secondNeighbor</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </div>
</div>

<p class="text-center">
    <img alt="reduceOnNeighbors Example" width="70%" src="fig/gelly-reduceOnNeighbors.png" />
</p>

<p>When the aggregation function is not associative and commutative or when it is desirable to return more than one values per vertex, one can use the more general
<code>groupReduceOnEdges()</code> and <code>groupReduceOnNeighbors()</code> methods.
These methods return zero, one or more values per vertex and provide access to the whole neighborhood.</p>

<p>For example, the following code will output all the vertex pairs which are connected with an edge having a weight of 0.5 or more:</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;,</span> <span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;&gt;</span> <span class="n">vertexPairs</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">groupReduceOnNeighbors</span><span class="o">(</span><span class="k">new</span> <span class="nf">SelectLargeWeightNeighbors</span><span class="o">(),</span> <span class="n">EdgeDirection</span><span class="o">.</span><span class="na">OUT</span><span class="o">);</span>

<span class="c1">// user-defined function to select the neighbors which have edges with weight &gt; 0.5</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">SelectLargeWeightNeighbors</span> <span class="kd">implements</span> <span class="n">NeighborsFunctionWithVertexValue</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span>
		<span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;,</span> <span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;&gt;</span> <span class="o">{</span>

		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">iterateNeighbors</span><span class="o">(</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">vertex</span><span class="o">,</span>
				<span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;,</span> <span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;&gt;</span> <span class="n">neighbors</span><span class="o">,</span>
				<span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;,</span> <span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>

			<span class="k">for</span> <span class="o">(</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;,</span> <span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">neighbors</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">neighbor</span><span class="o">.</span><span class="na">f0</span><span class="o">.</span><span class="na">f2</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;,</span> <span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;(</span><span class="n">vertex</span><span class="o">,</span> <span class="n">neighbor</span><span class="o">.</span><span class="na">f1</span><span class="o">));</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">vertexPairs</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">groupReduceOnNeighbors</span><span class="o">(</span><span class="k">new</span> <span class="nc">SelectLargeWeightNeighbors</span><span class="o">,</span> <span class="nc">EdgeDirection</span><span class="o">.</span><span class="nc">OUT</span><span class="o">)</span>

<span class="c1">// user-defined function to select the neighbors which have edges with weight &gt; 0.5</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">SelectLargeWeightNeighbors</span> <span class="k">extends</span> <span class="nc">NeighborsFunctionWithVertexValue</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span>, <span class="kt">Double</span>,
  <span class="o">(</span><span class="kt">Vertex</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">]</span>, <span class="kt">Vertex</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">])]</span> <span class="o">{</span>

	<span class="k">override</span> <span class="k">def</span> <span class="n">iterateNeighbors</span><span class="o">(</span><span class="n">vertex</span><span class="k">:</span> <span class="kt">Vertex</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">],</span>
		<span class="n">neighbors</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[(</span><span class="kt">Edge</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span><span class="o">]</span>, <span class="kt">Vertex</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">])],</span>
		<span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[(</span><span class="kt">Vertex</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">]</span>, <span class="kt">Vertex</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">])])</span> <span class="k">=</span> <span class="o">{</span>

			<span class="k">for</span> <span class="o">(</span><span class="n">neighbor</span> <span class="k">&lt;-</span> <span class="n">neighbors</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">neighbor</span><span class="o">.</span><span class="n">_1</span><span class="o">.</span><span class="n">getValue</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="n">vertex</span><span class="o">,</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">_2</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
   <span class="o">}</span></code></pre></div>

  </div>
</div>

<p>When the aggregation computation does not require access to the vertex value (for which the aggregation is performed), it is advised to use the more efficient <code>EdgesFunction</code> and <code>NeighborsFunction</code> for the user-defined functions. When access to the vertex value is required, one should use <code>EdgesFunctionWithVertexValue</code> and <code>NeighborsFunctionWithVertexValue</code> instead.</p>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="iterative-graph-processing">Iterative Graph Processing</h2>
<p>Gelly exploits Flink’s efficient iteration operators to support large-scale iterative graph processing. Currently, we provide implementations of the vertex-centric, scatter-gather, and gather-sum-apply models. In the following sections, we describe these abstractions and show how you can use them in Gelly.</p>

<h3 id="vertex-centric-iterations">Vertex-Centric Iterations</h3>
<p>The vertex-centric model, also known as “think like a vertex” or “Pregel”, expresses computation from the perspective of a vertex in the graph.
The computation proceeds in synchronized iteration steps, called supersteps. In each superstep, each vertex executes one user-defined function.
Vertices communicate with other vertices through messages. A vertex can send a message to any other vertex in the graph, as long as it knows its unique ID.</p>

<p>The computational model is shown in the figure below. The dotted boxes correspond to parallelization units.
In each superstep, all active vertices execute the
same user-defined computation in parallel. Supersteps are executed synchronously, so that messages sent during one superstep are guaranteed to be delivered in the beginning of the next superstep.</p>

<p class="text-center">
    <img alt="Vertex-Centric Computational Model" width="70%" src="fig/vertex-centric supersteps.png" />
</p>

<p>To use vertex-centric iterations in Gelly, the user only needs to define the vertex compute function, <code>ComputeFunction</code>.
This function and the maximum number of iterations to run are given as parameters to Gelly’s <code>runVertexCentricIteration</code>. This method will execute the vertex-centric iteration on the input Graph and return a new Graph, with updated vertex values. An optional message combiner, <code>MessageCombiner</code>, can be defined to reduce communication costs.</p>

<p>Let us consider computing Single-Source-Shortest-Paths with vertex-centric iterations. Initially, each vertex has a value of infinite distance, except from the source vertex, which has a value of zero. During the first superstep, the source propagates distances to its neighbors. During the following supersteps, each vertex checks its received messages and chooses the minimum distance among them. If this distance is smaller than its current value, it updates its state and produces messages for its neighbors. If a vertex does not change its value during a superstep, then it does not produce any messages for its neighbors for the next superstep. The algorithm converges when there are no value updates or the maximum number of supersteps has been reached. In this algorithm, a message combiner can be used to reduce the number of messages sent to a target vertex.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// read the input graph</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// define the maximum number of iterations</span>
<span class="kt">int</span> <span class="n">maxIterations</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

<span class="c1">// Execute the vertex-centric iteration</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">runVertexCentricIteration</span><span class="o">(</span>
            <span class="k">new</span> <span class="nf">SSSPComputeFunction</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">SSSPCombiner</span><span class="o">(),</span> <span class="n">maxIterations</span><span class="o">);</span>

<span class="c1">// Extract the vertices as the result</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">singleSourceShortestPaths</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getVertices</span><span class="o">();</span>


<span class="c1">// - - -  UDFs - - - //</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">SSSPComputeFunction</span> <span class="kd">extends</span> <span class="n">ComputeFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="o">{</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">compute</span><span class="o">(</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">vertex</span><span class="o">,</span> <span class="n">MessageIterator</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">messages</span><span class="o">)</span> <span class="o">{</span>

    <span class="kt">double</span> <span class="n">minDistance</span> <span class="o">=</span> <span class="o">(</span><span class="n">vertex</span><span class="o">.</span><span class="na">getId</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">srcId</span><span class="o">))</span> <span class="o">?</span> <span class="mi">0</span><span class="n">d</span> <span class="o">:</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">Double</span> <span class="n">msg</span> <span class="o">:</span> <span class="n">messages</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">minDistance</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minDistance</span><span class="o">,</span> <span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">minDistance</span> <span class="o">&lt;</span> <span class="n">vertex</span><span class="o">.</span><span class="na">getValue</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">setNewVertexValue</span><span class="o">(</span><span class="n">minDistance</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="nl">e:</span> <span class="n">getEdges</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">sendMessageTo</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getTarget</span><span class="o">(),</span> <span class="n">minDistance</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// message combiner</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">SSSPCombiner</span> <span class="kd">extends</span> <span class="n">MessageCombiner</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">combineMessages</span><span class="o">(</span><span class="n">MessageIterator</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">messages</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">double</span> <span class="n">minMessage</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Double</span> <span class="nl">msg:</span> <span class="n">messages</span><span class="o">)</span> <span class="o">{</span>
           <span class="n">minMessage</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minMessage</span><span class="o">,</span> <span class="n">msg</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">sendCombinedMessage</span><span class="o">(</span><span class="n">minMessage</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// read the input graph</span>
<span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// define the maximum number of iterations</span>
<span class="k">val</span> <span class="n">maxIterations</span> <span class="k">=</span> <span class="mi">10</span>

<span class="c1">// Execute the vertex-centric iteration</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">runVertexCentricIteration</span><span class="o">(</span><span class="k">new</span> <span class="nc">SSSPComputeFunction</span><span class="o">,</span> <span class="k">new</span> <span class="nc">SSSPCombiner</span><span class="o">,</span> <span class="n">maxIterations</span><span class="o">)</span>

<span class="c1">// Extract the vertices as the result</span>
<span class="k">val</span> <span class="n">singleSourceShortestPaths</span> <span class="k">=</span> <span class="n">result</span><span class="o">.</span><span class="n">getVertices</span>


<span class="c1">// - - -  UDFs - - - //</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">SSSPComputeFunction</span> <span class="k">extends</span> <span class="nc">ComputeFunction</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span>, <span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">compute</span><span class="o">(</span><span class="n">vertex</span><span class="k">:</span> <span class="kt">Vertex</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span><span class="o">],</span> <span class="n">messages</span><span class="k">:</span> <span class="kt">MessageIterator</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>

    <span class="k">var</span> <span class="n">minDistance</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">getId</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">srcId</span><span class="o">))</span> <span class="mi">0</span> <span class="k">else</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">MaxValue</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">messages</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">msg</span> <span class="k">=</span> <span class="n">messages</span><span class="o">.</span><span class="n">next</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">&lt;</span> <span class="n">minDistance</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">minDistance</span> <span class="k">=</span> <span class="n">msg</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">getValue</span> <span class="o">&gt;</span> <span class="n">minDistance</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">setNewVertexValue</span><span class="o">(</span><span class="n">minDistance</span><span class="o">)</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">edge</span><span class="k">:</span> <span class="kt">Edge</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">&lt;-</span> <span class="n">getEdges</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sendMessageTo</span><span class="o">(</span><span class="n">edge</span><span class="o">.</span><span class="n">getTarget</span><span class="o">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">getValue</span> <span class="o">+</span> <span class="n">edge</span><span class="o">.</span><span class="n">getValue</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// message combiner</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">SSSPCombiner</span> <span class="k">extends</span> <span class="nc">MessageCombiner</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">combineMessages</span><span class="o">(</span><span class="n">messages</span><span class="k">:</span> <span class="kt">MessageIterator</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span> <span class="o">{</span>

        <span class="k">var</span> <span class="n">minDistance</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">MaxValue</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">messages</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">val</span> <span class="n">msg</span> <span class="k">=</span> <span class="n">inMessages</span><span class="o">.</span><span class="n">next</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">&lt;</span> <span class="n">minDistance</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">minDistance</span> <span class="k">=</span> <span class="n">msg</span>
          <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">sendCombinedMessage</span><span class="o">(</span><span class="n">minMessage</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h3 id="configuring-a-vertex-centric-iteration">Configuring a Vertex-Centric Iteration</h3>
<p>A vertex-centric iteration can be configured using a <code>VertexCentricConfiguration</code> object.
Currently, the following parameters can be specified:</p>

<ul>
  <li>
    <p><strong>Name</strong>: The name for the vertex-centric iteration. The name is displayed in logs and messages
and can be specified using the <code>setName()</code> method.</p>
  </li>
  <li>
    <p><strong>Parallelism</strong>: The parallelism for the iteration. It can be set using the <code>setParallelism()</code> method.</p>
  </li>
  <li>
    <p><strong>Solution set in unmanaged memory</strong>: Defines whether the solution set is kept in managed memory (Flink’s internal way of keeping objects in serialized form) or as a simple object map. By default, the solution set runs in managed memory. This property can be set using the <code>setSolutionSetUnmanagedMemory()</code> method.</p>
  </li>
  <li>
    <p><strong>Aggregators</strong>: Iteration aggregators can be registered using the <code>registerAggregator()</code> method. An iteration aggregator combines
all aggregates globally once per superstep and makes them available in the next superstep. Registered aggregators can be accessed inside the user-defined <code>ComputeFunction</code>.</p>
  </li>
  <li>
    <p><strong>Broadcast Variables</strong>: DataSets can be added as <a href="/apis/batch/index.html#broadcast-variables">Broadcast Variables</a> to the <code>ComputeFunction</code>, using the <code>addBroadcastSet()</code> method.</p>
  </li>
</ul>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// configure the iteration</span>
<span class="n">VertexCentricConfiguration</span> <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">VertexCentricConfiguration</span><span class="o">();</span>

<span class="c1">// set the iteration name</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;Gelly Iteration&quot;</span><span class="o">);</span>

<span class="c1">// set the parallelism</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">setParallelism</span><span class="o">(</span><span class="mi">16</span><span class="o">);</span>

<span class="c1">// register an aggregator</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">registerAggregator</span><span class="o">(</span><span class="s">&quot;sumAggregator&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="nf">LongSumAggregator</span><span class="o">());</span>

<span class="c1">// run the vertex-centric iteration, also passing the configuration parameters</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
            <span class="n">graph</span><span class="o">.</span><span class="na">runVertexCentricIteration</span><span class="o">(</span>
            <span class="k">new</span> <span class="nf">Compute</span><span class="o">(),</span> <span class="kc">null</span><span class="o">,</span> <span class="n">maxIterations</span><span class="o">,</span> <span class="n">parameters</span><span class="o">);</span>

<span class="c1">// user-defined function</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Compute</span> <span class="kd">extends</span> <span class="n">ComputeFunction</span> <span class="o">{</span>

    <span class="n">LongSumAggregator</span> <span class="n">aggregator</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">LongSumAggregator</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">preSuperstep</span><span class="o">()</span> <span class="o">{</span>

        <span class="c1">// retrieve the Aggregator</span>
        <span class="n">aggregator</span> <span class="o">=</span> <span class="n">getIterationAggregator</span><span class="o">(</span><span class="s">&quot;sumAggregator&quot;</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">compute</span><span class="o">(</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">vertex</span><span class="o">,</span> <span class="n">MessageIterator</span> <span class="n">inMessages</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//do some computation</span>
        <span class="n">Long</span> <span class="n">partialValue</span> <span class="o">=</span> <span class="o">...</span>

        <span class="c1">// aggregate the partial value</span>
        <span class="n">aggregator</span><span class="o">.</span><span class="na">aggregate</span><span class="o">(</span><span class="n">partialValue</span><span class="o">);</span>

        <span class="c1">// update the vertex value</span>
        <span class="n">setNewVertexValue</span><span class="o">(...);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">parameters</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VertexCentricConfiguration</span>

<span class="c1">// set the iteration name</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">setName</span><span class="o">(</span><span class="s">&quot;Gelly Iteration&quot;</span><span class="o">)</span>

<span class="c1">// set the parallelism</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">setParallelism</span><span class="o">(</span><span class="mi">16</span><span class="o">)</span>

<span class="c1">// register an aggregator</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">registerAggregator</span><span class="o">(</span><span class="s">&quot;sumAggregator&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LongSumAggregator</span><span class="o">)</span>

<span class="c1">// run the vertex-centric iteration, also passing the configuration parameters</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">runVertexCentricIteration</span><span class="o">(</span><span class="k">new</span> <span class="nc">Compute</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Combiner</span><span class="o">,</span> <span class="n">maxIterations</span><span class="o">,</span> <span class="n">parameters</span><span class="o">)</span>

<span class="c1">// user-defined function</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">Compute</span> <span class="k">extends</span> <span class="nc">ComputeFunction</span> <span class="o">{</span>

    <span class="k">var</span> <span class="n">aggregator</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">LongSumAggregator</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">preSuperstep</span> <span class="o">{</span>

        <span class="c1">// retrieve the Aggregator</span>
        <span class="n">aggregator</span> <span class="k">=</span> <span class="n">getIterationAggregator</span><span class="o">(</span><span class="s">&quot;sumAggregator&quot;</span><span class="o">)</span>
    <span class="o">}</span>


    <span class="k">override</span> <span class="k">def</span> <span class="n">compute</span><span class="o">(</span><span class="n">vertex</span><span class="k">:</span> <span class="kt">Vertex</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">],</span> <span class="n">inMessages</span><span class="k">:</span> <span class="kt">MessageIterator</span><span class="o">[</span><span class="kt">Long</span><span class="o">])</span> <span class="o">{</span>

        <span class="c1">//do some computation</span>
        <span class="k">val</span> <span class="n">partialValue</span> <span class="k">=</span> <span class="o">...</span>

        <span class="c1">// aggregate the partial value</span>
        <span class="n">aggregator</span><span class="o">.</span><span class="n">aggregate</span><span class="o">(</span><span class="n">partialValue</span><span class="o">)</span>

        <span class="c1">// update the vertex value</span>
        <span class="n">setNewVertexValue</span><span class="o">(...)</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h3 id="scatter-gather-iterations">Scatter-Gather Iterations</h3>
<p>The scatter-gather model, also known as “signal/collect” model, expresses computation from the perspective of a vertex in the graph. The computation proceeds in synchronized iteration steps, called supersteps. In each superstep, a vertex produces messages for other vertices and updates its value based on the messages it receives. To use scatter-gather iterations in Gelly, the user only needs to define how a vertex behaves in each superstep:</p>

<ul>
  <li><strong>Messaging</strong>:  corresponds to the scatter phase and produces the messages that a vertex will send to other vertices.</li>
  <li><strong>Value Update</strong>: corresponds to the gather phase and updates the vertex value using the received messages.</li>
</ul>

<p>Gelly provides methods for scatter-gather iterations. The user only needs to implement two functions, corresponding to the scatter and gather phases. The first function is a <code>MessagingFunction</code>, which allows a vertex to send out messages for other vertices. Messages are recieved during the same superstep as they are sent. The second function is <code>VertexUpdateFunction</code>, which defines how a vertex will update its value based on the received messages.
These functions and the maximum number of iterations to run are given as parameters to Gelly’s <code>runScatterGatherIteration</code>. This method will execute the scatter-gather iteration on the input Graph and return a new Graph, with updated vertex values.</p>

<p>A scatter-gather iteration can be extended with information such as the total number of vertices, the in degree and out degree.
Additionally, the  neighborhood type (in/out/all) over which to run the scatter-gather iteration can be specified. By default, the updates from the in-neighbors are used to modify the current vertex’s state and messages are sent to out-neighbors.</p>

<p>Let us consider computing Single-Source-Shortest-Paths with scatter-gather iterations on the following graph and let vertex 1 be the source. In each superstep, each vertex sends a candidate distance message to all its neighbors. The message value is the sum of the current value of the vertex and the edge weight connecting this vertex with its neighbor. Upon receiving candidate distance messages, each vertex calculates the minimum distance and, if a shorter path has been discovered, it updates its value. If a vertex does not change its value during a superstep, then it does not produce messages for its neighbors for the next superstep. The algorithm converges when there are no value updates.</p>

<p class="text-center">
    <img alt="Scatter-gather SSSP superstep 1" width="70%" src="fig/gelly-vc-sssp1.png" />
</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// read the input graph</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// define the maximum number of iterations</span>
<span class="kt">int</span> <span class="n">maxIterations</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

<span class="c1">// Execute the scatter-gather iteration</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">runScatterGatherIteration</span><span class="o">(</span>
			<span class="k">new</span> <span class="nf">VertexDistanceUpdater</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">MinDistanceMessenger</span><span class="o">(),</span> <span class="n">maxIterations</span><span class="o">);</span>

<span class="c1">// Extract the vertices as the result</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">singleSourceShortestPaths</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getVertices</span><span class="o">();</span>


<span class="c1">// - - -  UDFs - - - //</span>

<span class="c1">// scatter: messaging</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">MinDistanceMessenger</span> <span class="kd">extends</span> <span class="n">MessagingFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendMessages</span><span class="o">(</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">vertex</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">getEdges</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">sendMessageTo</span><span class="o">(</span><span class="n">edge</span><span class="o">.</span><span class="na">getTarget</span><span class="o">(),</span> <span class="n">vertex</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">edge</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// gather: vertex update</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">VertexDistanceUpdater</span> <span class="kd">extends</span> <span class="n">VertexUpdateFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateVertex</span><span class="o">(</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">vertex</span><span class="o">,</span> <span class="n">MessageIterator</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">inMessages</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Double</span> <span class="n">minDistance</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

		<span class="k">for</span> <span class="o">(</span><span class="kt">double</span> <span class="n">msg</span> <span class="o">:</span> <span class="n">inMessages</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">&lt;</span> <span class="n">minDistance</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">minDistance</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">vertex</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">minDistance</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">setNewVertexValue</span><span class="o">(</span><span class="n">minDistance</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// read the input graph</span>
<span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// define the maximum number of iterations</span>
<span class="k">val</span> <span class="n">maxIterations</span> <span class="k">=</span> <span class="mi">10</span>

<span class="c1">// Execute the scatter-gather iteration</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">runScatterGatherIteration</span><span class="o">(</span><span class="k">new</span> <span class="nc">VertexDistanceUpdater</span><span class="o">,</span> <span class="k">new</span> <span class="nc">MinDistanceMessenger</span><span class="o">,</span> <span class="n">maxIterations</span><span class="o">)</span>

<span class="c1">// Extract the vertices as the result</span>
<span class="k">val</span> <span class="n">singleSourceShortestPaths</span> <span class="k">=</span> <span class="n">result</span><span class="o">.</span><span class="n">getVertices</span>


<span class="c1">// - - -  UDFs - - - //</span>

<span class="c1">// messaging</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">MinDistanceMessenger</span> <span class="k">extends</span> <span class="nc">MessagingFunction</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span>, <span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="o">{</span>

	<span class="k">override</span> <span class="k">def</span> <span class="n">sendMessages</span><span class="o">(</span><span class="n">vertex</span><span class="k">:</span> <span class="kt">Vertex</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="n">edge</span><span class="k">:</span> <span class="kt">Edge</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">&lt;-</span> <span class="n">getEdges</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">sendMessageTo</span><span class="o">(</span><span class="n">edge</span><span class="o">.</span><span class="n">getTarget</span><span class="o">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">getValue</span> <span class="o">+</span> <span class="n">edge</span><span class="o">.</span><span class="n">getValue</span><span class="o">)</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// vertex update</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">VertexDistanceUpdater</span> <span class="k">extends</span> <span class="nc">VertexUpdateFunction</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="o">{</span>

	<span class="k">override</span> <span class="k">def</span> <span class="n">updateVertex</span><span class="o">(</span><span class="n">vertex</span><span class="k">:</span> <span class="kt">Vertex</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span><span class="o">],</span> <span class="n">inMessages</span><span class="k">:</span> <span class="kt">MessageIterator</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
		<span class="k">var</span> <span class="n">minDistance</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">MaxValue</span>

		<span class="k">while</span> <span class="o">(</span><span class="n">inMessages</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span> <span class="o">{</span>
		  <span class="k">val</span> <span class="n">msg</span> <span class="k">=</span> <span class="n">inMessages</span><span class="o">.</span><span class="n">next</span>
		  <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">&lt;</span> <span class="n">minDistance</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">minDistance</span> <span class="k">=</span> <span class="n">msg</span>
		  <span class="o">}</span>
		<span class="o">}</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">getValue</span> <span class="o">&gt;</span> <span class="n">minDistance</span><span class="o">)</span> <span class="o">{</span>
		  <span class="n">setNewVertexValue</span><span class="o">(</span><span class="n">minDistance</span><span class="o">)</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h3 id="configuring-a-scatter-gather-iteration">Configuring a Scatter-Gather Iteration</h3>
<p>A scatter-gather iteration can be configured using a <code>ScatterGatherConfiguration</code> object.
Currently, the following parameters can be specified:</p>

<ul>
  <li>
    <p><strong>Name</strong>: The name for the scatter-gather iteration. The name is displayed in logs and messages
and can be specified using the <code>setName()</code> method.</p>
  </li>
  <li>
    <p><strong>Parallelism</strong>: The parallelism for the iteration. It can be set using the <code>setParallelism()</code> method.</p>
  </li>
  <li>
    <p><strong>Solution set in unmanaged memory</strong>: Defines whether the solution set is kept in managed memory (Flink’s internal way of keeping objects in serialized form) or as a simple object map. By default, the solution set runs in managed memory. This property can be set using the <code>setSolutionSetUnmanagedMemory()</code> method.</p>
  </li>
  <li>
    <p><strong>Aggregators</strong>: Iteration aggregators can be registered using the <code>registerAggregator()</code> method. An iteration aggregator combines
all aggregates globally once per superstep and makes them available in the next superstep. Registered aggregators can be accessed inside the user-defined <code>VertexUpdateFunction</code> and <code>MessagingFunction</code>.</p>
  </li>
  <li>
    <p><strong>Broadcast Variables</strong>: DataSets can be added as <a href="/apis/batch/index.html#broadcast-variables">Broadcast Variables</a> to the <code>VertexUpdateFunction</code> and <code>MessagingFunction</code>, using the <code>addBroadcastSetForUpdateFunction()</code> and <code>addBroadcastSetForMessagingFunction()</code> methods, respectively.</p>
  </li>
  <li>
    <p><strong>Number of Vertices</strong>: Accessing the total number of vertices within the iteration. This property can be set using the <code>setOptNumVertices()</code> method.
The number of vertices can then be accessed in the vertex update function and in the messaging function using the <code>getNumberOfVertices()</code> method. If the option is not set in the configuration, this method will return -1.</p>
  </li>
  <li>
    <p><strong>Degrees</strong>: Accessing the in/out degree for a vertex within an iteration. This property can be set using the <code>setOptDegrees()</code> method.
The in/out degrees can then be accessed in the vertex update function and in the messaging function, per vertex using the <code>getInDegree()</code> and <code>getOutDegree()</code> methods.
If the degrees option is not set in the configuration, these methods will return -1.</p>
  </li>
  <li>
    <p><strong>Messaging Direction</strong>: By default, a vertex sends messages to its out-neighbors and updates its value based on messages received from its in-neighbors. This configuration option allows users to change the messaging direction to either <code>EdgeDirection.IN</code>, <code>EdgeDirection.OUT</code>, <code>EdgeDirection.ALL</code>. The messaging direction also dictates the update direction which would be <code>EdgeDirection.OUT</code>, <code>EdgeDirection.IN</code> and <code>EdgeDirection.ALL</code>, respectively. This property can be set using the <code>setDirection()</code> method.</p>
  </li>
</ul>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// configure the iteration</span>
<span class="n">ScatterGatherConfiguration</span> <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ScatterGatherConfiguration</span><span class="o">();</span>

<span class="c1">// set the iteration name</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;Gelly Iteration&quot;</span><span class="o">);</span>

<span class="c1">// set the parallelism</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">setParallelism</span><span class="o">(</span><span class="mi">16</span><span class="o">);</span>

<span class="c1">// register an aggregator</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">registerAggregator</span><span class="o">(</span><span class="s">&quot;sumAggregator&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="nf">LongSumAggregator</span><span class="o">());</span>

<span class="c1">// run the scatter-gather iteration, also passing the configuration parameters</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
			<span class="n">graph</span><span class="o">.</span><span class="na">runScatterGatherIteration</span><span class="o">(</span>
			<span class="k">new</span> <span class="nf">VertexUpdater</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">Messenger</span><span class="o">(),</span> <span class="n">maxIterations</span><span class="o">,</span> <span class="n">parameters</span><span class="o">);</span>

<span class="c1">// user-defined functions</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">VertexUpdater</span> <span class="kd">extends</span> <span class="n">VertexUpdateFunction</span> <span class="o">{</span>

	<span class="n">LongSumAggregator</span> <span class="n">aggregator</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">LongSumAggregator</span><span class="o">();</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">preSuperstep</span><span class="o">()</span> <span class="o">{</span>

		<span class="c1">// retrieve the Aggregator</span>
		<span class="n">aggregator</span> <span class="o">=</span> <span class="n">getIterationAggregator</span><span class="o">(</span><span class="s">&quot;sumAggregator&quot;</span><span class="o">);</span>
	<span class="o">}</span>


	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateVertex</span><span class="o">(</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">vertex</span><span class="o">,</span> <span class="n">MessageIterator</span> <span class="n">inMessages</span><span class="o">)</span> <span class="o">{</span>

		<span class="c1">//do some computation</span>
		<span class="n">Long</span> <span class="n">partialValue</span> <span class="o">=</span> <span class="o">...</span>

		<span class="c1">// aggregate the partial value</span>
		<span class="n">aggregator</span><span class="o">.</span><span class="na">aggregate</span><span class="o">(</span><span class="n">partialValue</span><span class="o">);</span>

		<span class="c1">// update the vertex value</span>
		<span class="n">setNewVertexValue</span><span class="o">(...);</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Messenger</span> <span class="kd">extends</span> <span class="n">MessagingFunction</span> <span class="o">{...}</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">parameters</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ScatterGatherConfiguration</span>

<span class="c1">// set the iteration name</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">setName</span><span class="o">(</span><span class="s">&quot;Gelly Iteration&quot;</span><span class="o">)</span>

<span class="c1">// set the parallelism</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">setParallelism</span><span class="o">(</span><span class="mi">16</span><span class="o">)</span>

<span class="c1">// register an aggregator</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">registerAggregator</span><span class="o">(</span><span class="s">&quot;sumAggregator&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LongSumAggregator</span><span class="o">)</span>

<span class="c1">// run the scatter-gather iteration, also passing the configuration parameters</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">runScatterGatherIteration</span><span class="o">(</span><span class="k">new</span> <span class="nc">VertexUpdater</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Messenger</span><span class="o">,</span> <span class="n">maxIterations</span><span class="o">,</span> <span class="n">parameters</span><span class="o">)</span>

<span class="c1">// user-defined functions</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">VertexUpdater</span> <span class="k">extends</span> <span class="nc">VertexUpdateFunction</span> <span class="o">{</span>

	<span class="k">var</span> <span class="n">aggregator</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">LongSumAggregator</span>

	<span class="k">override</span> <span class="k">def</span> <span class="n">preSuperstep</span> <span class="o">{</span>

		<span class="c1">// retrieve the Aggregator</span>
		<span class="n">aggregator</span> <span class="k">=</span> <span class="n">getIterationAggregator</span><span class="o">(</span><span class="s">&quot;sumAggregator&quot;</span><span class="o">)</span>
	<span class="o">}</span>


	<span class="k">override</span> <span class="k">def</span> <span class="n">updateVertex</span><span class="o">(</span><span class="n">vertex</span><span class="k">:</span> <span class="kt">Vertex</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">],</span> <span class="n">inMessages</span><span class="k">:</span> <span class="kt">MessageIterator</span><span class="o">[</span><span class="kt">Long</span><span class="o">])</span> <span class="o">{</span>

		<span class="c1">//do some computation</span>
		<span class="k">val</span> <span class="n">partialValue</span> <span class="k">=</span> <span class="o">...</span>

		<span class="c1">// aggregate the partial value</span>
		<span class="n">aggregator</span><span class="o">.</span><span class="n">aggregate</span><span class="o">(</span><span class="n">partialValue</span><span class="o">)</span>

		<span class="c1">// update the vertex value</span>
		<span class="n">setNewVertexValue</span><span class="o">(...)</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Messenger</span> <span class="k">extends</span> <span class="nc">MessagingFunction</span> <span class="o">{...}</span></code></pre></div>

  </div>
</div>

<p>The following example illustrates the usage of the degree as well as the number of vertices options.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// configure the iteration</span>
<span class="n">ScatterGatherConfiguration</span> <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ScatterGatherConfiguration</span><span class="o">();</span>

<span class="c1">// set the number of vertices option to true</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">setOptNumVertices</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

<span class="c1">// set the degree option to true</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">setOptDegrees</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

<span class="c1">// run the scatter-gather iteration, also passing the configuration parameters</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
			<span class="n">graph</span><span class="o">.</span><span class="na">runScatterGatherIteration</span><span class="o">(</span>
			<span class="k">new</span> <span class="nf">VertexUpdater</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">Messenger</span><span class="o">(),</span> <span class="n">maxIterations</span><span class="o">,</span> <span class="n">parameters</span><span class="o">);</span>

<span class="c1">// user-defined functions</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">VertexUpdater</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="c1">// get the number of vertices</span>
	<span class="kt">long</span> <span class="n">numVertices</span> <span class="o">=</span> <span class="n">getNumberOfVertices</span><span class="o">();</span>
	<span class="o">...</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Messenger</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="c1">// retrieve the vertex out-degree</span>
	<span class="n">outDegree</span> <span class="o">=</span> <span class="n">getOutDegree</span><span class="o">();</span>
	<span class="o">...</span>
<span class="o">}</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// configure the iteration</span>
<span class="k">val</span> <span class="n">parameters</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ScatterGatherConfiguration</span>

<span class="c1">// set the number of vertices option to true</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">setOptNumVertices</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>

<span class="c1">// set the degree option to true</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">setOptDegrees</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>

<span class="c1">// run the scatter-gather iteration, also passing the configuration parameters</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">runScatterGatherIteration</span><span class="o">(</span><span class="k">new</span> <span class="nc">VertexUpdater</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Messenger</span><span class="o">,</span> <span class="n">maxIterations</span><span class="o">,</span> <span class="n">parameters</span><span class="o">)</span>

<span class="c1">// user-defined functions</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">VertexUpdater</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="c1">// get the number of vertices</span>
	<span class="k">val</span> <span class="n">numVertices</span> <span class="k">=</span> <span class="n">getNumberOfVertices</span>
	<span class="o">...</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Messenger</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="c1">// retrieve the vertex out-degree</span>
	<span class="k">val</span> <span class="n">outDegree</span> <span class="k">=</span> <span class="n">getOutDegree</span>
	<span class="o">...</span>
<span class="o">}</span></code></pre></div>

  </div>
</div>

<p>The following example illustrates the usage of the edge direction option. Vertices update their values to contain a list of all their in-neighbors.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// configure the iteration</span>
<span class="n">ScatterGatherConfiguration</span> <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ScatterGatherConfiguration</span><span class="o">();</span>

<span class="c1">// set the messaging direction</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">setDirection</span><span class="o">(</span><span class="n">EdgeDirection</span><span class="o">.</span><span class="na">IN</span><span class="o">);</span>

<span class="c1">// run the scatter-gather iteration, also passing the configuration parameters</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span>
			<span class="n">graph</span><span class="o">.</span><span class="na">runScatterGatherIteration</span><span class="o">(</span>
			<span class="k">new</span> <span class="nf">VertexUpdater</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">Messenger</span><span class="o">(),</span> <span class="n">maxIterations</span><span class="o">,</span> <span class="n">parameters</span><span class="o">)</span>
			<span class="o">.</span><span class="na">getVertices</span><span class="o">();</span>

<span class="c1">// user-defined functions</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">VertexUpdater</span> <span class="o">{...}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Messenger</span> <span class="o">{...}</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">HashSet</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// configure the iteration</span>
<span class="k">val</span> <span class="n">parameters</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ScatterGatherConfiguration</span>

<span class="c1">// set the messaging direction</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">setDirection</span><span class="o">(</span><span class="nc">EdgeDirection</span><span class="o">.</span><span class="nc">IN</span><span class="o">)</span>

<span class="c1">// run the scatter-gather iteration, also passing the configuration parameters</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">runScatterGatherIteration</span><span class="o">(</span><span class="k">new</span> <span class="nc">VertexUpdater</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Messenger</span><span class="o">,</span> <span class="n">maxIterations</span><span class="o">,</span> <span class="n">parameters</span><span class="o">)</span>
			<span class="o">.</span><span class="n">getVertices</span>

<span class="c1">// user-defined functions</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">VertexUpdater</span> <span class="o">{...}</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Messenger</span> <span class="o">{...}</span></code></pre></div>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h3 id="gather-sum-apply-iterations">Gather-Sum-Apply Iterations</h3>
<p>Like in the scatter-gather model, Gather-Sum-Apply also proceeds in synchronized iterative steps, called supersteps. Each superstep consists of the following three phases:</p>

<ul>
  <li><strong>Gather</strong>: a user-defined function is invoked in parallel on the edges and neighbors of each vertex, producing a partial value.</li>
  <li><strong>Sum</strong>: the partial values produced in the Gather phase are aggregated to a single value, using a user-defined reducer.</li>
  <li><strong>Apply</strong>:  each vertex value is updated by applying a function on the current value and the aggregated value produced by the Sum phase.</li>
</ul>

<p>Let us consider computing Single-Source-Shortest-Paths with GSA on the following graph and let vertex 1 be the source. During the <code>Gather</code> phase, we calculate the new candidate distances, by adding each vertex value with the edge weight. In <code>Sum</code>, the candidate distances are grouped by vertex ID and the minimum distance is chosen. In <code>Apply</code>, the newly calculated distance is compared to the current vertex value and the minimum of the two is assigned as the new value of the vertex.</p>

<p class="text-center">
    <img alt="GSA SSSP superstep 1" width="70%" src="fig/gelly-gsa-sssp1.png" />
</p>

<p>Notice that, if a vertex does not change its value during a superstep, it will not calculate candidate distance during the next superstep. The algorithm converges when no vertex changes value.</p>

<p>To implement this example in Gelly GSA, the user only needs to call the <code>runGatherSumApplyIteration</code> method on the input graph and provide the <code>GatherFunction</code>, <code>SumFunction</code> and <code>ApplyFunction</code> UDFs. Iteration synchronization, grouping, value updates and convergence are handled by the system:</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// read the input graph</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// define the maximum number of iterations</span>
<span class="kt">int</span> <span class="n">maxIterations</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

<span class="c1">// Execute the GSA iteration</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">runGatherSumApplyIteration</span><span class="o">(</span>
				<span class="k">new</span> <span class="nf">CalculateDistances</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">ChooseMinDistance</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">UpdateDistance</span><span class="o">(),</span> <span class="n">maxIterations</span><span class="o">);</span>

<span class="c1">// Extract the vertices as the result</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">singleSourceShortestPaths</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getVertices</span><span class="o">();</span>


<span class="c1">// - - -  UDFs - - - //</span>

<span class="c1">// Gather</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">CalculateDistances</span> <span class="kd">extends</span> <span class="n">GatherFunction</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="n">Double</span> <span class="nf">gather</span><span class="o">(</span><span class="n">Neighbor</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">neighbor</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">neighbor</span><span class="o">.</span><span class="na">getNeighborValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">neighbor</span><span class="o">.</span><span class="na">getEdgeValue</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Sum</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ChooseMinDistance</span> <span class="kd">extends</span> <span class="n">SumFunction</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="n">Double</span> <span class="nf">sum</span><span class="o">(</span><span class="n">Double</span> <span class="n">newValue</span><span class="o">,</span> <span class="n">Double</span> <span class="n">currentValue</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">newValue</span><span class="o">,</span> <span class="n">currentValue</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Apply</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">UpdateDistance</span> <span class="kd">extends</span> <span class="n">ApplyFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="n">Double</span> <span class="n">newDistance</span><span class="o">,</span> <span class="n">Double</span> <span class="n">oldDistance</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">newDistance</span> <span class="o">&lt;</span> <span class="n">oldDistance</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">setResult</span><span class="o">(</span><span class="n">newDistance</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// read the input graph</span>
<span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// define the maximum number of iterations</span>
<span class="k">val</span> <span class="n">maxIterations</span> <span class="k">=</span> <span class="mi">10</span>

<span class="c1">// Execute the GSA iteration</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">runGatherSumApplyIteration</span><span class="o">(</span><span class="k">new</span> <span class="nc">CalculateDistances</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ChooseMinDistance</span><span class="o">,</span> <span class="k">new</span> <span class="nc">UpdateDistance</span><span class="o">,</span> <span class="n">maxIterations</span><span class="o">)</span>

<span class="c1">// Extract the vertices as the result</span>
<span class="k">val</span> <span class="n">singleSourceShortestPaths</span> <span class="k">=</span> <span class="n">result</span><span class="o">.</span><span class="n">getVertices</span>


<span class="c1">// - - -  UDFs - - - //</span>

<span class="c1">// Gather</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">CalculateDistances</span> <span class="k">extends</span> <span class="nc">GatherFunction</span><span class="o">[</span><span class="kt">Double</span>, <span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="o">{</span>

	<span class="k">override</span> <span class="k">def</span> <span class="n">gather</span><span class="o">(</span><span class="n">neighbor</span><span class="k">:</span> <span class="kt">Neighbor</span><span class="o">[</span><span class="kt">Double</span>, <span class="kt">Double</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
		<span class="n">neighbor</span><span class="o">.</span><span class="n">getNeighborValue</span> <span class="o">+</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">getEdgeValue</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Sum</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">ChooseMinDistance</span> <span class="k">extends</span> <span class="nc">SumFunction</span><span class="o">[</span><span class="kt">Double</span>, <span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="o">{</span>

	<span class="k">override</span> <span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">newValue</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">currentValue</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
		<span class="nc">Math</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="n">newValue</span><span class="o">,</span> <span class="n">currentValue</span><span class="o">)</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Apply</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">UpdateDistance</span> <span class="k">extends</span> <span class="nc">ApplyFunction</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="o">{</span>

	<span class="k">override</span> <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">newDistance</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">oldDistance</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">newDistance</span> <span class="o">&lt;</span> <span class="n">oldDistance</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">setResult</span><span class="o">(</span><span class="n">newDistance</span><span class="o">)</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </div>
</div>

<p>Note that <code>gather</code> takes a <code>Neighbor</code> type as an argument. This is a convenience type which simply wraps a vertex with its neighboring edge.</p>

<p>For more examples of how to implement algorithms with the Gather-Sum-Apply model, check the <a href="https://github.com/apache/flink/blob/master//flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/library/GSAPageRank.java">GSAPageRank</a> and <a href="https://github.com/apache/flink/blob/master//flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/library/GSAConnectedComponents.java">GSAConnectedComponents</a> library methods of Gelly.</p>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h3 id="configuring-a-gather-sum-apply-iteration">Configuring a Gather-Sum-Apply Iteration</h3>
<p>A GSA iteration can be configured using a <code>GSAConfiguration</code> object.
Currently, the following parameters can be specified:</p>

<ul>
  <li>
    <p><strong>Name</strong>: The name for the GSA iteration. The name is displayed in logs and messages and can be specified using the <code>setName()</code> method.</p>
  </li>
  <li>
    <p><strong>Parallelism</strong>: The parallelism for the iteration. It can be set using the <code>setParallelism()</code> method.</p>
  </li>
  <li>
    <p><strong>Solution set in unmanaged memory</strong>: Defines whether the solution set is kept in managed memory (Flink’s internal way of keeping objects in serialized form) or as a simple object map. By default, the solution set runs in managed memory. This property can be set using the <code>setSolutionSetUnmanagedMemory()</code> method.</p>
  </li>
  <li>
    <p><strong>Aggregators</strong>: Iteration aggregators can be registered using the <code>registerAggregator()</code> method. An iteration aggregator combines all aggregates globally once per superstep and makes them available in the next superstep. Registered aggregators can be accessed inside the user-defined <code>GatherFunction</code>, <code>SumFunction</code> and <code>ApplyFunction</code>.</p>
  </li>
  <li>
    <p><strong>Broadcast Variables</strong>: DataSets can be added as <a href="/apis/index.html#broadcast-variables">Broadcast Variables</a> to the <code>GatherFunction</code>, <code>SumFunction</code> and <code>ApplyFunction</code>, using the methods <code>addBroadcastSetForGatherFunction()</code>, <code>addBroadcastSetForSumFunction()</code> and <code>addBroadcastSetForApplyFunction</code> methods, respectively.</p>
  </li>
  <li>
    <p><strong>Number of Vertices</strong>: Accessing the total number of vertices within the iteration. This property can be set using the <code>setOptNumVertices()</code> method.
The number of vertices can then be accessed in the gather, sum and/or apply functions by using the <code>getNumberOfVertices()</code> method. If the option is not set in the configuration, this method will return -1.</p>
  </li>
  <li>
    <p><strong>Neighbor Direction</strong>: By default values are gathered from the out neighbors of the Vertex. This can be modified
using the <code>setDirection()</code> method.</p>
  </li>
</ul>

<p>The following example illustrates the usage of the number of vertices option.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// configure the iteration</span>
<span class="n">GSAConfiguration</span> <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">GSAConfiguration</span><span class="o">();</span>

<span class="c1">// set the number of vertices option to true</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">setOptNumVertices</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

<span class="c1">// run the gather-sum-apply iteration, also passing the configuration parameters</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">runGatherSumApplyIteration</span><span class="o">(</span>
				<span class="k">new</span> <span class="nf">Gather</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">Sum</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">Apply</span><span class="o">(),</span>
			    <span class="n">maxIterations</span><span class="o">,</span> <span class="n">parameters</span><span class="o">);</span>

<span class="c1">// user-defined functions</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Gather</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="c1">// get the number of vertices</span>
	<span class="kt">long</span> <span class="n">numVertices</span> <span class="o">=</span> <span class="n">getNumberOfVertices</span><span class="o">();</span>
	<span class="o">...</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Sum</span> <span class="o">{</span>
	<span class="o">...</span>
    <span class="c1">// get the number of vertices</span>
    <span class="kt">long</span> <span class="n">numVertices</span> <span class="o">=</span> <span class="n">getNumberOfVertices</span><span class="o">();</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Apply</span> <span class="o">{</span>
	<span class="o">...</span>
    <span class="c1">// get the number of vertices</span>
    <span class="kt">long</span> <span class="n">numVertices</span> <span class="o">=</span> <span class="n">getNumberOfVertices</span><span class="o">();</span>
    <span class="o">...</span>
<span class="o">}</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// configure the iteration</span>
<span class="k">val</span> <span class="n">parameters</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">GSAConfiguration</span>

<span class="c1">// set the number of vertices option to true</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">setOptNumVertices</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>

<span class="c1">// run the gather-sum-apply iteration, also passing the configuration parameters</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">runGatherSumApplyIteration</span><span class="o">(</span><span class="k">new</span> <span class="nc">Gather</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Sum</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Apply</span><span class="o">,</span> <span class="n">maxIterations</span><span class="o">,</span> <span class="n">parameters</span><span class="o">)</span>

<span class="c1">// user-defined functions</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">Gather</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="c1">// get the number of vertices</span>
	<span class="k">val</span> <span class="n">numVertices</span> <span class="k">=</span> <span class="n">getNumberOfVertices</span>
	<span class="o">...</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Sum</span> <span class="o">{</span>
	<span class="o">...</span>
    <span class="c1">// get the number of vertices</span>
    <span class="k">val</span> <span class="n">numVertices</span> <span class="k">=</span> <span class="n">getNumberOfVertices</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Apply</span> <span class="o">{</span>
	<span class="o">...</span>
    <span class="c1">// get the number of vertices</span>
    <span class="k">val</span> <span class="n">numVertices</span> <span class="k">=</span> <span class="n">getNumberOfVertices</span>
    <span class="o">...</span>
<span class="o">}</span></code></pre></div>

  </div>
</div>

<p>The following example illustrates the usage of the edge direction option.</p>
<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// configure the iteration</span>
<span class="n">GSAConfiguration</span> <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">GSAConfiguration</span><span class="o">();</span>

<span class="c1">// set the messaging direction</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">setDirection</span><span class="o">(</span><span class="n">EdgeDirection</span><span class="o">.</span><span class="na">IN</span><span class="o">);</span>

<span class="c1">// run the gather-sum-apply iteration, also passing the configuration parameters</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span>
			<span class="n">graph</span><span class="o">.</span><span class="na">runGatherSumApplyIteration</span><span class="o">(</span>
			<span class="k">new</span> <span class="nf">Gather</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">Sum</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">Apply</span><span class="o">(),</span> <span class="n">maxIterations</span><span class="o">,</span> <span class="n">parameters</span><span class="o">)</span>
			<span class="o">.</span><span class="na">getVertices</span><span class="o">();</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">HashSet</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// configure the iteration</span>
<span class="k">val</span> <span class="n">parameters</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">GSAConfiguration</span>

<span class="c1">// set the messaging direction</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">setDirection</span><span class="o">(</span><span class="nc">EdgeDirection</span><span class="o">.</span><span class="nc">IN</span><span class="o">)</span>

<span class="c1">// run the gather-sum-apply iteration, also passing the configuration parameters</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">runGatherSumApplyIteration</span><span class="o">(</span><span class="k">new</span> <span class="nc">Gather</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Sum</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Apply</span><span class="o">,</span> <span class="n">maxIterations</span><span class="o">,</span> <span class="n">parameters</span><span class="o">)</span>
			<span class="o">.</span><span class="n">getVertices</span><span class="o">()</span></code></pre></div>

  </div>
</div>
<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h3 id="iteration-abstractions-comparison">Iteration Abstractions Comparison</h3>
<p>Although the three iteration abstractions in Gelly seem quite similar, understanding their differences can lead to more performant and maintainable programs.
Among the three, the vertex-centric model is the most general model and supports arbitrary computation and messaging for each vertex. In the scatter-gather model, the logic of producing messages is decoupled from the logic of updating vertex values. Thus, programs written using scatter-gather are sometimes easier to follow and maintain.
Separating the messaging phase from the vertex value update logic not only makes some programs easier to follow but might also have a positive impact on performance. Scatter-gather implementations typically have lower memory requirements, because concurrent access to the inbox (messages received) and outbox (messages to send) data structures is not required. However, this characteristic also limits expressiveness and makes some computation patterns non-intuitive. Naturally, if an algorithm requires a vertex to concurrently access its inbox and outbox, then the expression of this algorithm in scatter-gather might be problematic. Strongly Connected Components and Approximate Maximum
Weight Matching are examples of such graph algorithms. A direct consequence of this restriction is that vertices cannot generate messages and update their states in the same phase. Thus, deciding whether to propagate a message based on its content would require storing it in the vertex value, so that the gather phase has access to it, in the following iteration step. Similarly, if the vertex update logic includes computation over the values of the neighboring edges, these have to be included inside a special message passed from the scatter to the gather phase. Such workarounds often lead to higher memory requirements and non-elegant, hard to understand algorithm implementations.</p>

<p>Gather-sum-apply iterations are also quite similar to scatter-gather iterations. In fact, any algorithm which can be expressed as a GSA iteration can also be written in the scatter-gather model. The messaging phase of the scatter-gather model is equivalent to the Gather and Sum steps of GSA: Gather can be seen as the phase where the messages are produced and Sum as the phase where they are routed to the target vertex. Similarly, the value update phase corresponds to the Apply step.</p>

<p>The main difference between the two implementations is that the Gather phase of GSA parallelizes the computation over the edges, while the messaging phase distributes the computation over the vertices. Using the SSSP examples above, we see that in the first superstep of the scatter-gather case, vertices 1, 2 and 3 produce messages in parallel. Vertex 1 produces 3 messages, while vertices 2 and 3 produce one message each. In the GSA case on the other hand, the computation is parallelized over the edges: the three candidate distance values of vertex 1 are produced in parallel. Thus, if the Gather step contains “heavy” computation, it might be a better idea to use GSA and spread out the computation, instead of burdening a single vertex. Another case when parallelizing over the edges might prove to be more efficient is when the input graph is skewed (some vertices have a lot more neighbors than others).</p>

<p>Another difference between the two implementations is that the scatter-gather implementation uses a <code>coGroup</code> operator internally, while GSA uses a <code>reduce</code>. Therefore, if the function that combines neighbor values (messages) requires the whole group of values for the computation, scatter-gather should be used. If the update function is associative and commutative, then the GSA’s reducer is expected to give a more efficient implementation, as it can make use of a combiner.</p>

<p>Another thing to note is that GSA works strictly on neighborhoods, while in the vertex-centric and scatter-gather models, a vertex can send a message to any vertex, given that it knows its vertex ID, regardless of whether it is a neighbor. Finally, in Gelly’s scatter-gather implementation, one can choose the messaging direction, i.e. the direction in which updates propagate. GSA does not support this yet, so each vertex will be updated based on the values of its in-neighbors only.</p>

<p>The main differences among the Gelly iteration models are shown in the table below.</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 25%">Iteration Model</th>
      <th class="text-center">Update Function</th>
      <th class="text-center">Update Logic</th>
      <th class="text-center">Communication Scope</th>
      <th class="text-center">Communication Logic</th>
    </tr>
  </thead>
  <tbody>
 <tr>
  <td>Vertex-Centric</td>
  <td>arbitrary</td>
  <td>arbitrary</td>
  <td>any vertex</td>
  <td>arbitrary</td>
</tr>
<tr>
  <td>Scatter-Gather</td>
  <td>arbitrary</td>
  <td>based on received messages</td>
  <td>any vertex</td>
  <td>based on vertex state</td>
</tr>
<tr>
  <td>Gather-Sum-Apply</td>
  <td>associative and commutative</td>
  <td>based on neighbors' values</td>
  <td>neighborhood</td>
  <td>based on vertex state</td>
</tr>
</tbody>
</table>

<h2 id="graph-validation">Graph Validation</h2>

<p>Gelly provides a simple utility for performing validation checks on input graphs. Depending on the application context, a graph may or may not be valid according to certain criteria. For example, a user might need to validate whether their graph contains duplicate edges or whether its structure is bipartite. In order to validate a graph, one can define a custom <code>GraphValidator</code> and implement its <code>validate()</code> method. <code>InvalidVertexIdsValidator</code> is Gelly’s pre-defined validator. It checks that the edge set contains valid vertex IDs, i.e. that all edge IDs
also exist in the vertex IDs set.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="c1">// create a list of vertices with IDs = {1, 2, 3, 4, 5}</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">vertices</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// create a list of edges with IDs = {(1, 2) (1, 3), (2, 4), (5, 6)}</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">edges</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="na">fromCollection</span><span class="o">(</span><span class="n">vertices</span><span class="o">,</span> <span class="n">edges</span><span class="o">,</span> <span class="n">env</span><span class="o">);</span>

<span class="c1">// will return false: 6 is an invalid ID</span>
<span class="n">graph</span><span class="o">.</span><span class="na">validate</span><span class="o">(</span><span class="k">new</span> <span class="n">InvalidVertexIdsValidator</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;());</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="c1">// create a list of vertices with IDs = {1, 2, 3, 4, 5}</span>
<span class="k">val</span> <span class="n">vertices</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Vertex</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// create a list of edges with IDs = {(1, 2) (1, 3), (2, 4), (5, 6)}</span>
<span class="k">val</span> <span class="n">edges</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Edge</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">vertices</span><span class="o">,</span> <span class="n">edges</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span>

<span class="c1">// will return false: 6 is an invalid ID</span>
<span class="n">graph</span><span class="o">.</span><span class="n">validate</span><span class="o">(</span><span class="k">new</span> <span class="nc">InvalidVertexIdsValidator</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span>, <span class="kt">Long</span><span class="o">])</span></code></pre></div>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="library-methods">Library Methods</h2>
<p>Gelly has a growing collection of graph algorithms for easily analyzing large-scale Graphs. So far, the following library methods are implemented:</p>

<ul>
  <li><a href="#community-detection">Community Detection</a></li>
  <li><a href="#label-propagation">Label Propagation</a></li>
  <li><a href="#connected-components">Connected Components</a></li>
  <li><a href="#gsa-connected-components">GSA Connected Components</a></li>
  <li><a href="#pagerank">PageRank</a></li>
  <li><a href="#gsa-pagerank">GSA PageRank</a></li>
  <li><a href="#single-source-shortest-paths">Single Source Shortest Paths</a></li>
  <li><a href="#gsa-single-source-shortest-paths">GSA Single Source Shortest Paths</a></li>
  <li><a href="#gsa-triangle-count">GSA Triangle Count</a></li>
  <li><a href="#triangle-enumerator">Triangle Enumerator</a></li>
  <li><a href="#summarization">Summarization</a></li>
  <li><a href="#jaccard-index">Jaccard Index</a></li>
  <li><a href="#local-clustering-coefficient">Local Clustering Coefficient</a></li>
</ul>

<p>Gelly’s library methods can be used by simply calling the <code>run()</code> method on the input graph:</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// run Label Propagation for 30 iterations to detect communities on the input graph</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">verticesWithCommunity</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="k">new</span> <span class="n">LabelPropagation</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;(</span><span class="mi">30</span><span class="o">));</span>

<span class="c1">// print the result</span>
<span class="n">verticesWithCommunity</span><span class="o">.</span><span class="na">print</span><span class="o">();</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span>, <span class="kt">NullValue</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// run Label Propagation for 30 iterations to detect communities on the input graph</span>
<span class="k">val</span> <span class="n">verticesWithCommunity</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="k">new</span> <span class="nc">LabelPropagation</span><span class="o">[</span><span class="kt">Long</span><span class="o">](</span><span class="mi">30</span><span class="o">))</span>

<span class="c1">// print the result</span>
<span class="n">verticesWithCommunity</span><span class="o">.</span><span class="n">print</span></code></pre></div>

  </div>
</div>

<h3 id="community-detection">Community Detection</h3>

<h4 id="overview">Overview</h4>
<p>In graph theory, communities refer to groups of nodes that are well connected internally, but sparsely connected to other groups.
This library method is an implementation of the community detection algorithm described in the paper <a href="http://arxiv.org/pdf/0808.2633.pdf%22%3Earticle%20explaining%20the%20algorithm%20in%20detail">Towards real-time community detection in large networks</a>.</p>

<h4 id="details">Details</h4>
<p>The algorithm is implemented using <a href="#scatter-gather-iterations">scatter-gather iterations</a>.
Initially, each vertex is assigned a <code>Tuple2</code> containing its initial value along with a score equal to 1.0.
In each iteration, vertices send their labels and scores to their neighbors. Upon receiving messages from its neighbors,
a vertex chooses the label with the highest score and subsequently re-scores it using the edge values,
a user-defined hop attenuation parameter, <code>delta</code>, and the superstep number.
The algorithm converges when vertices no longer update their value or when the maximum number of iterations
is reached.</p>

<h4 id="usage">Usage</h4>
<p>The algorithm takes as input a <code>Graph</code> with any vertex type, <code>Long</code> vertex values, and <code>Double</code> edge values. It returns a <code>Graph</code> of the same type as the input,
where the vertex values correspond to the community labels, i.e. two vertices belong to the same community if they have the same vertex value.
The constructor takes two parameters:</p>

<ul>
  <li><code>maxIterations</code>: the maximum number of iterations to run.</li>
  <li><code>delta</code>: the hop attenuation parameter, with default value 0.5.</li>
</ul>

<h3 id="label-propagation">Label Propagation</h3>

<h4 id="overview-1">Overview</h4>
<p>This is an implementation of the well-known Label Propagation algorithm described in <a href="http://journals.aps.org/pre/abstract/10.1103/PhysRevE.76.036106">this paper</a>. The algorithm discovers communities in a graph, by iteratively propagating labels between neighbors. Unlike the <a href="#community-detection">Community Detection library method</a>, this implementation does not use scores associated with the labels.</p>

<h4 id="details-1">Details</h4>
<p>The algorithm is implemented using <a href="#scatter-gather-iterations">scatter-gather iterations</a>.
Labels are expected to be of type <code>Comparable</code> and are initialized using the vertex values of the input <code>Graph</code>.
The algorithm iteratively refines discovered communities by propagating labels. In each iteration, a vertex adopts
the label that is most frequent among its neighbors’ labels. In case of a tie (i.e. two or more labels appear with the
same frequency), the algorithm picks the greater label. The algorithm converges when no vertex changes its value or
the maximum number of iterations has been reached. Note that different initializations might lead to different results.</p>

<h4 id="usage-1">Usage</h4>
<p>The algorithm takes as input a <code>Graph</code> with a <code>Comparable</code> vertex type, a <code>Comparable</code> vertex value type and an arbitrary edge value type.
It returns a <code>DataSet</code> of vertices, where the vertex value corresponds to the community in which this vertex belongs after convergence.
The constructor takes one parameter:</p>

<ul>
  <li><code>maxIterations</code>: the maximum number of iterations to run.</li>
</ul>

<h3 id="connected-components">Connected Components</h3>

<h4 id="overview-2">Overview</h4>
<p>This is an implementation of the Weakly Connected Components algorithm. Upon convergence, two vertices belong to the 
same component, if there is a path from one to the other, without taking edge direction into account.</p>

<h4 id="details-2">Details</h4>
<p>The algorithm is implemented using <a href="#scatter-gather-iterations">scatter-gather iterations</a>.
This implementation uses a comparable vertex value as initial component identifier (ID). Vertices propagate their 
current value in each iteration. Upon receiving component IDs from its neighbors, a vertex adopts a new component ID if 
its value is lower than its current component ID. The algorithm converges when vertices no longer update their component 
ID value or when the maximum number of iterations has been reached.</p>

<h4 id="usage-2">Usage</h4>
<p>The result is a <code>DataSet</code> of vertices, where the vertex value corresponds to the assigned component.
The constructor takes one parameter:</p>

<ul>
  <li><code>maxIterations</code>: the maximum number of iterations to run.</li>
</ul>

<h3 id="gsa-connected-components">GSA Connected Components</h3>

<h4 id="overview-3">Overview</h4>
<p>This is an implementation of the Weakly Connected Components algorithm. Upon convergence, two vertices belong to the 
same component, if there is a path from one to the other, without taking edge direction into account.</p>

<h4 id="details-3">Details</h4>
<p>The algorithm is implemented using <a href="#gather-sum-apply-iterations">gather-sum-apply iterations</a>.
This implementation uses a comparable vertex value as initial component identifier (ID). In the gather phase, each 
vertex collects the vertex value of their adjacent vertices. In the sum phase, the minimum among those values is 
selected. In the apply phase, the algorithm sets the minimum value as the new vertex value if it is smaller than 
the current value. The algorithm converges when vertices no longer update their component ID value or when the
maximum number of iterations has been reached.</p>

<h4 id="usage-3">Usage</h4>
<p>The result is a <code>DataSet</code> of vertices, where the vertex value corresponds to the assigned component.
The constructor takes one parameter:</p>

<ul>
  <li><code>maxIterations</code>: the maximum number of iterations to run.</li>
</ul>

<h3 id="pagerank">PageRank</h3>

<h4 id="overview-4">Overview</h4>
<p>An implementation of a simple <a href="https://en.wikipedia.org/wiki/PageRank">PageRank algorithm</a>, using <a href="#scatter-gather-iterations">scatter-gather iterations</a>.
PageRank is an algorithm that was first used to rank web search engine results. Today, the algorithm and many variations, are used in various graph application domains. The idea of PageRank is that important or relevant pages tend to link to other important pages.</p>

<h4 id="details-4">Details</h4>
<p>The algorithm operates in iterations, where pages distribute their scores to their neighbors (pages they have links to) and subsequently update their scores based on the partial values they receive. The implementation assumes that each page has at least one incoming and one outgoing link.
In order to consider the importance of a link from one page to another, scores are divided by the total number of out-links of the source page. Thus, a page with 10 links will distribute 1/10 of its score to each neighbor, while a page with 100 links, will distribute 1/100 of its score to each neighboring page. This process computes what is often called the transition probablities, i.e. the probability that some page will lead to other page while surfing the web. To correctly compute the transition probabilities, this implementation expects the edge values to be initialised to 1.0.</p>

<h4 id="usage-4">Usage</h4>
<p>The algorithm takes as input a <code>Graph</code> with any vertex type, <code>Double</code> vertex values, and <code>Double</code> edge values. Edges values should be initialized to 1.0, in order to correctly compute the transition probabilities. Otherwise, the transition probability for an Edge <code>(u, v)</code> will be set to the edge value divided by <code>u</code>’s out-degree. The algorithm returns a <code>DataSet</code> of vertices, where the vertex value corresponds to assigned rank after convergence (or maximum iterations).
The constructors take the following parameters:</p>

<ul>
  <li><code>beta</code>: the damping factor.</li>
  <li><code>maxIterations</code>: the maximum number of iterations to run.</li>
  <li><code>numVertices</code>: the number of vertices in the input. If known beforehand, is it advised to provide this argument to speed up execution.</li>
</ul>

<h3 id="gsa-pagerank">GSA PageRank</h3>

<p>The algorithm is implemented using <a href="#gather-sum-apply-iterations">gather-sum-apply iterations</a>.</p>

<p>See the <a href="#pagerank">PageRank</a> library method for implementation details and usage information.</p>

<h3 id="single-source-shortest-paths">Single Source Shortest Paths</h3>

<h4 id="overview-5">Overview</h4>
<p>An implementation of the Single-Source-Shortest-Paths algorithm for weighted graphs. Given a source vertex, the algorithm computes the shortest paths from this source to all other nodes in the graph.</p>

<h4 id="details-5">Details</h4>
<p>The algorithm is implemented using <a href="#scatter-gather-iterations">scatter-gather iterations</a>.
In each iteration, a vertex sends to its neighbors a message containing the sum its current distance and the edge weight connecting this vertex with the neighbor. Upon receiving candidate distance messages, a vertex calculates the minimum distance and, if a shorter path has been discovered, it updates its value. If a vertex does not change its value during a superstep, then it does not produce messages for its neighbors for the next superstep. The computation terminates after the specified maximum number of supersteps or when there are no value updates.</p>

<h4 id="usage-5">Usage</h4>
<p>The algorithm takes as input a <code>Graph</code> with any vertex type, <code>Double</code> vertex values, and <code>Double</code> edge values. The output is a <code>DataSet</code> of vertices where the vertex values
correspond to the minimum distances from the given source vertex.
The constructor takes two parameters:</p>

<ul>
  <li><code>srcVertexId</code> The vertex ID of the source vertex.</li>
  <li><code>maxIterations</code>: the maximum number of iterations to run.</li>
</ul>

<h3 id="gsa-single-source-shortest-paths">GSA Single Source Shortest Paths</h3>

<p>The algorithm is implemented using <a href="#gather-sum-apply-iterations">gather-sum-apply iterations</a>.</p>

<p>See the <a href="#single-source-shortest-paths">Single Source Shortest Paths</a> library method for implementation details and usage information.</p>

<h3 id="gsa-triangle-count">GSA Triangle Count</h3>

<h4 id="overview-6">Overview</h4>
<p>An implementation of the Triangle Count algorithm. Given an input graph, it returns the number of unique triangles in it.</p>

<h4 id="details-6">Details</h4>
<p>This algorithm operates in three phases. First, vertices select neighbors with IDs greater than theirs
and send messages to them. Each received message is then propagated to neighbors with higher IDs.
Finally, if a node encounters the target ID in the list of received messages, it increments the number of discovered triangles.</p>

<h4 id="usage-6">Usage</h4>
<p>The algorithm takes an undirected, unweighted graph as input and outputs a <code>DataSet</code> which contains a single integer corresponding to the number of triangles
in the graph. The algorithm constructor takes no arguments.</p>

<h3 id="triangle-enumerator">Triangle Enumerator</h3>

<h4 id="overview-7">Overview</h4>
<p>This library method enumerates unique triangles present in the input graph. A triangle consists of three edges that connect three vertices with each other.
This implementation ignores edge directions.</p>

<h4 id="details-7">Details</h4>
<p>The basic triangle enumeration algorithm groups all edges that share a common vertex and builds triads, i.e., triples of vertices
that are connected by two edges. Then, all triads are filtered for which no third edge exists that closes the triangle.
For a group of <i>n</i> edges that share a common vertex, the number of built triads is quadratic <i>((n*(n-1))/2)</i>.
Therefore, an optimization of the algorithm is to group edges on the vertex with the smaller output degree to reduce the number of triads.
This implementation extends the basic algorithm by computing output degrees of edge vertices and grouping on edges on the vertex with the smaller degree.</p>

<h4 id="usage-7">Usage</h4>
<p>The algorithm takes a directed graph as input and outputs a <code>DataSet</code> of <code>Tuple3</code>. The Vertex ID type has to be <code>Comparable</code>.
Each <code>Tuple3</code> corresponds to a triangle, with the fields containing the IDs of the vertices forming the triangle.</p>

<h3 id="summarization">Summarization</h3>

<h4 id="overview-8">Overview</h4>
<p>The summarization algorithm computes a condensed version of the input graph by grouping vertices and edges based on
their values. In doing so, the algorithm helps to uncover insights about patterns and distributions in the graph.
One possible use case is the visualization of communities where the whole graph is too large and needs to be summarized
based on the community identifier stored at a vertex.</p>

<h4 id="details-8">Details</h4>
<p>In the resulting graph, each vertex represents a group of vertices that share the same value. An edge, that connects a
vertex with itself, represents all edges with the same edge value that connect vertices from the same vertex group. An
edge between different vertices in the output graph represents all edges with the same edge value between members of
different vertex groups in the input graph.</p>

<p>The algorithm is implemented using Flink data operators. First, vertices are grouped by their value and a representative
is chosen from each group. For any edge, the source and target vertex identifiers are replaced with the corresponding
representative and grouped by source, target and edge value. Output vertices and edges are created from their
corresponding groupings.</p>

<h4 id="usage-8">Usage</h4>
<p>The algorithm takes a directed, vertex (and possibly edge) attributed graph as input and outputs a new graph where each
vertex represents a group of vertices and each edge represents a group of edges from the input graph. Furthermore, each
vertex and edge in the output graph stores the common group value and the number of represented elements.</p>

<h3 id="jaccard-index">Jaccard Index</h3>

<h4 id="overview-9">Overview</h4>
<p>The Jaccard Index measures the similarity between vertex neighborhoods and is computed as the number of shared neighbors
divided by the number of distinct neighbors. Scores range from 0.0 (no shared neighbors) to 1.0 (all neighbors are
shared).</p>

<h4 id="details-9">Details</h4>
<p>Counting shared neighbors for pairs of vertices is equivalent to counting connecting paths of length two. The number of
distinct neighbors is computed by storing the sum of degrees of the vertex pair and subtracting the count of shared
neighbors, which are double-counted in the sum of degrees.</p>

<p>The algorithm first annotates each edge with the target vertex’s degree. Grouping on the source vertex, each pair of
neighbors is emitted with the degree sum. Grouping on two-paths, the shared neighbors are counted.</p>

<h4 id="usage-9">Usage</h4>
<p>The algorithm takes a simple, undirected graph as input and outputs a <code>DataSet</code> of tuples containing two vertex IDs,
the number of shared neighbors, and the number of distinct neighbors. The result class provides a method to compute the
Jaccard Index score. The graph ID type must be <code>Comparable</code> and <code>Copyable</code>.</p>

<ul>
  <li><code>setLittleParallelism</code>: override the parallelism of operators processing small amounts of data</li>
  <li><code>setMaximumScore</code>: filter out Jaccard Index scores greater than or equal to the given maximum fraction</li>
  <li><code>setMinimumScore</code>: filter out Jaccard Index scores less than the given minimum fraction</li>
</ul>

<h3 id="local-clustering-coefficient">Local Clustering Coefficient</h3>

<h4 id="overview-10">Overview</h4>
<p>The local clustering coefficient measures the connectedness of each vertex’s neighborhood. Scores range from 0.0 (no
edges between neighbors) to 1.0 (neighborhood is a clique).</p>

<h4 id="details-10">Details</h4>
<p>An edge between a vertex’s neighbors is a triangle. Counting edges between neighbors is equivalent to counting the
number of triangles which include the vertex. The clustering coefficient score is the number of edges between neighbors
divided by the number of potential edges between neighbors.</p>

<p>See the <a href="#triangle-enumeration">Triangle Enumeration</a> library method for a detailed explanation of triangle enumeration.</p>

<h4 id="usage-10">Usage</h4>
<p>The algorithm takes a simple, undirected graph as input and outputs a <code>DataSet</code> of tuples containing the vertex ID,
vertex degree, and number of triangles containing the vertex. The vertex ID must be <code>Comparable</code> and <code>Copyable</code>.</p>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="graph-algorithms">Graph Algorithms</h2>

<p>The logic blocks with which the <code>Graph</code> API and top-level algorithms are assembled are accessible in Gelly as graph
algorithms in the <code>org.apache.flink.graph.asm</code> package. These algorithms provide optimization and tuning through
configuration parameters and may provide implicit runtime reuse when processing the same input with a similar
configuration.</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">Algorithm</th>
      <th class="text-center">Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>degree.annotate.directed.<br /><strong>VertexInDegree</strong></td>
      <td>
        <p>Annotate vertices of a <a href="#graph-representation">directed graph</a> with the in-degree.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">LongValue</span><span class="o">&gt;&gt;</span> <span class="n">inDegree</span> <span class="o">=</span> <span class="n">graph</span>
  <span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="k">new</span> <span class="nf">VertexInDegree</span><span class="o">()</span>
    <span class="o">.</span><span class="na">setIncludeZeroDegreeVertices</span><span class="o">(</span><span class="kc">true</span><span class="o">));</span></code></pre></div>

        <p>Optional configuration:</p>
        <ul>
          <li><p><strong>setIncludeZeroDegreeVertices</strong>: by default only the edge set is processed for the computation of degree; when this flag is set an additional join is performed against the vertex set in order to output vertices with an in-degree of zero</p></li>
          <li><p><strong>setParallelism</strong>: override the operator parallelism</p></li>
        </ul>
      </td>
    </tr>

    <tr>
      <td>degree.annotate.directed.<br /><strong>VertexOutDegree</strong></td>
      <td>
        <p>Annotate vertices of a <a href="#graph-representation">directed graph</a> with the out-degree.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">LongValue</span><span class="o">&gt;&gt;</span> <span class="n">outDegree</span> <span class="o">=</span> <span class="n">graph</span>
  <span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="k">new</span> <span class="nf">VertexOutDegree</span><span class="o">()</span>
    <span class="o">.</span><span class="na">setIncludeZeroDegreeVertices</span><span class="o">(</span><span class="kc">true</span><span class="o">));</span></code></pre></div>

        <p>Optional configuration:</p>
        <ul>
          <li><p><strong>setIncludeZeroDegreeVertices</strong>: by default only the edge set is processed for the computation of degree; when this flag is set an additional join is performed against the vertex set in order to output vertices with an out-degree of zero</p></li>
          <li><p><strong>setParallelism</strong>: override the operator parallelism</p></li>
        </ul>
      </td>
    </tr>

    <tr>
      <td>degree.annotate.directed.<br /><strong>VertexDegreePair</strong></td>
      <td>
        <p>Annotate vertices of a <a href="#graph-representation">directed graph</a> with both the out-degree and in-degree.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">LongValue</span><span class="o">,</span> <span class="n">LongValue</span><span class="o">&gt;&gt;&gt;</span> <span class="n">pairDegree</span> <span class="o">=</span> <span class="n">graph</span>
  <span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="k">new</span> <span class="nf">VertexDegreePair</span><span class="o">()</span>
    <span class="o">.</span><span class="na">setIncludeZeroDegreeVertices</span><span class="o">(</span><span class="kc">true</span><span class="o">));</span></code></pre></div>

        <p>Optional configuration:</p>
        <ul>
          <li><p><strong>setIncludeZeroDegreeVertices</strong>: by default only the edge set is processed for the computation of degree; when this flag is set an additional join is performed against the vertex set in order to output vertices with out- and in-degree of zero</p></li>
          <li><p><strong>setParallelism</strong>: override the operator parallelism</p></li>
        </ul>
      </td>
    </tr>

    <tr>
      <td>degree.annotate.undirected.<br /><strong>VertexDegree</strong></td>
      <td>
        <p>Annotate vertices of an <a href="#graph-representation">undirected graph</a> with the degree.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">LongValue</span><span class="o">&gt;&gt;</span> <span class="n">degree</span> <span class="o">=</span> <span class="n">graph</span>
  <span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="k">new</span> <span class="nf">VertexDegree</span><span class="o">()</span>
    <span class="o">.</span><span class="na">setIncludeZeroDegreeVertices</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
    <span class="o">.</span><span class="na">setReduceOnTargetId</span><span class="o">(</span><span class="kc">true</span><span class="o">));</span></code></pre></div>

        <p>Optional configuration:</p>
        <ul>
          <li><p><strong>setIncludeZeroDegreeVertices</strong>: by default only the edge set is processed for the computation of degree; when this flag is set an additional join is performed against the vertex set in order to output vertices with a degree of zero</p></li>
          <li><p><strong>setParallelism</strong>: override the operator parallelism</p></li>
          <li><p><strong>setReduceOnTargetId</strong>: the degree can be counted from either the edge source or target IDs. By default the source IDs are counted. Reducing on target IDs may optimize the algorithm if the input edge list is sorted by target ID.</p></li>
        </ul>
      </td>
    </tr>

    <tr>
      <td>degree.annotate.undirected.<br /><strong>EdgeSourceDegree</strong></td>
      <td>
        <p>Annotate edges of an <a href="#graph-representation">undirected graph</a> with degree of the source ID.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">EV</span><span class="o">,</span> <span class="n">LongValue</span><span class="o">&gt;&gt;&gt;</span> <span class="n">sourceDegree</span> <span class="o">=</span> <span class="n">graph</span>
  <span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="k">new</span> <span class="nf">EdgeSourceDegree</span><span class="o">()</span>
    <span class="o">.</span><span class="na">setReduceOnTargetId</span><span class="o">(</span><span class="kc">true</span><span class="o">));</span></code></pre></div>

        <p>Optional configuration:</p>
        <ul>
          <li><p><strong>setParallelism</strong>: override the operator parallelism</p></li>
          <li><p><strong>setReduceOnTargetId</strong>: the degree can be counted from either the edge source or target IDs. By default the source IDs are counted. Reducing on target IDs may optimize the algorithm if the input edge list is sorted by target ID.</p></li>
        </ul>
      </td>
    </tr>

    <tr>
      <td>degree.annotate.undirected.<br /><strong>EdgeTargetDegree</strong></td>
      <td>
        <p>Annotate edges of an <a href="#graph-representation">undirected graph</a> with degree of the target ID.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">EV</span><span class="o">,</span> <span class="n">LongValue</span><span class="o">&gt;&gt;&gt;</span> <span class="n">targetDegree</span> <span class="o">=</span> <span class="n">graph</span>
  <span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="k">new</span> <span class="nf">EdgeTargetDegree</span><span class="o">()</span>
    <span class="o">.</span><span class="na">setReduceOnSourceId</span><span class="o">(</span><span class="kc">true</span><span class="o">));</span></code></pre></div>

        <p>Optional configuration:</p>
        <ul>
          <li><p><strong>setParallelism</strong>: override the operator parallelism</p></li>
          <li><p><strong>setReduceOnSourceId</strong>: the degree can be counted from either the edge source or target IDs. By default the target IDs are counted. Reducing on source IDs may optimize the algorithm if the input edge list is sorted by source ID.</p></li>
        </ul>
      </td>
    </tr>

    <tr>
      <td>degree.annotate.undirected.<br /><strong>EdgeDegreePair</strong></td>
      <td>
        <p>Annotate edges of an <a href="#graph-representation">undirected graph</a> with the degree of both the source and target degree ID.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">EV</span><span class="o">,</span> <span class="n">LongValue</span><span class="o">,</span> <span class="n">LongValue</span><span class="o">&gt;&gt;&gt;</span> <span class="n">pairDegree</span> <span class="o">=</span> <span class="n">graph</span>
  <span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="k">new</span> <span class="nf">EdgeDegreePair</span><span class="o">()</span>
    <span class="o">.</span><span class="na">setReduceOnTargetId</span><span class="o">(</span><span class="kc">true</span><span class="o">));</span></code></pre></div>

        <p>Optional configuration:</p>
        <ul>
          <li><p><strong>setParallelism</strong>: override the operator parallelism</p></li>
          <li><p><strong>setReduceOnTargetId</strong>: the degree can be counted from either the edge source or target IDs. By default the source IDs are counted. Reducing on target IDs may optimize the algorithm if the input edge list is sorted by target ID.</p></li>
        </ul>
      </td>
    </tr>

    <tr>
      <td>translate.<br /><strong>TranslateGraphIds</strong></td>
      <td>
        <p>Translate vertex and edge IDs using the given <code>TranslateFunction</code>.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">graph</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="k">new</span> <span class="nf">TranslateGraphIds</span><span class="o">(</span><span class="k">new</span> <span class="nf">LongValueToStringValue</span><span class="o">()));</span></code></pre></div>

        <p>Required configuration:</p>
        <ul>
          <li><p><strong>translator</strong>: implements type or value conversion</p></li>
        </ul>
      </td>
    </tr>

    <tr>
      <td>translate.<br /><strong>TranslateVertexValues</strong></td>
      <td>
        <p>Translate vertex values using the given <code>TranslateFunction</code>.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">graph</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="k">new</span> <span class="nf">TranslateVertexValues</span><span class="o">(</span><span class="k">new</span> <span class="nf">LongValueAddOffset</span><span class="o">(</span><span class="n">vertexCount</span><span class="o">)));</span></code></pre></div>

        <p>Required configuration:</p>
        <ul>
          <li><p><strong>translator</strong>: implements type or value conversion</p></li>
        </ul>
      </td>
    </tr>

    <tr>
      <td>translate.<br /><strong>TranslateEdgeValues</strong></td>
      <td>
        <p>Translate edge values using the given <code>TranslateFunction</code>.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">graph</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="k">new</span> <span class="nf">TranslateEdgeValues</span><span class="o">(</span><span class="k">new</span> <span class="nf">Nullify</span><span class="o">()));</span></code></pre></div>

        <p>Required configuration:</p>
        <ul>
          <li><p><strong>translator</strong>: implements type or value conversion</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="graph-generators">Graph Generators</h2>

<p>Gelly provides a collection of scalable graph generators. Each generator is</p>

<ul>
  <li>parallelizable, in order to create large datasets</li>
  <li>scale-free, generating the same graph regardless of parallelism</li>
  <li>thrifty, using as few operators as possible</li>
</ul>

<p>Graph generators are configured using the builder pattern. The parallelism of generator
operators can be set explicitly by calling <code>setParallelism(parallelism)</code>. Lowering the
parallelism will reduce the allocation of memory and network buffers.</p>

<p>Graph-specific configuration must be called first, then configuration common to all
generators, and lastly the call to <code>generate()</code>. The following example configures a
grid graph with two dimensions, configures the parallelism, and generates the graph.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="kt">boolean</span> <span class="n">wrapEndpoints</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">parallelism</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">LongValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">GridGraph</span><span class="o">(</span><span class="n">env</span><span class="o">)</span>
    <span class="o">.</span><span class="na">addDimension</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">wrapEndpoints</span><span class="o">)</span>
    <span class="o">.</span><span class="na">addDimension</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">wrapEndpoints</span><span class="o">)</span>
    <span class="o">.</span><span class="na">setParallelism</span><span class="o">(</span><span class="n">parallelism</span><span class="o">)</span>
    <span class="o">.</span><span class="na">generate</span><span class="o">();</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.graph.generator.GridGraph</span>

<span class="k">val</span> <span class="n">env</span><span class="k">:</span> <span class="kt">ExecutionEnvironment</span> <span class="o">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="n">wrapEndpoints</span> <span class="k">=</span> <span class="kc">false</span>

<span class="k">val</span> <span class="n">parallelism</span> <span class="k">=</span> <span class="mi">4</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">GridGraph</span><span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="n">getJavaEnv</span><span class="o">).</span><span class="n">addDimension</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">wrapEndpoints</span><span class="o">).</span><span class="n">addDimension</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">wrapEndpoints</span><span class="o">).</span><span class="n">setParallelism</span><span class="o">(</span><span class="n">parallelism</span><span class="o">).</span><span class="n">generate</span><span class="o">()</span></code></pre></div>

  </div>
</div>

<h3 id="provided-graph-generators">Provided graph generators</h3>

<ul>
  <li><a href="#complete-graph">Complete Graph</a></li>
  <li><a href="#cycle-graph">Cycle Graph</a></li>
  <li><a href="#empty-graph">Empty Graph</a></li>
  <li><a href="#grid-graph">Grid Graph</a></li>
  <li><a href="#hypercube-graph">Hypercube Graph</a></li>
  <li><a href="#path-graph">Path Graph</a></li>
  <li><a href="#rmat-graph">RMat Graph</a></li>
  <li><a href="#singleton-edge-graph">Singleton Edge Graph</a></li>
  <li><a href="#star-graph">Star Graph</a></li>
</ul>

<h3 id="complete-graph">Complete Graph</h3>

<p>An undirected graph connecting every distinct pair of vertices.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="kt">long</span> <span class="n">vertexCount</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">LongValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">CompleteGraph</span><span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">)</span>
    <span class="o">.</span><span class="na">generate</span><span class="o">();</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.graph.generator.CompleteGraph</span>

<span class="k">val</span> <span class="n">env</span><span class="k">:</span> <span class="kt">ExecutionEnvironment</span> <span class="o">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">vertexCount</span> <span class="k">=</span> <span class="mi">5</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CompleteGraph</span><span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="n">getJavaEnv</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">).</span><span class="n">generate</span><span class="o">()</span></code></pre></div>

  </div>
</div>

<svg class="graph" width="540" height="540" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

    <line x1="270" y1="40" x2="489" y2="199" />
    <line x1="270" y1="40" x2="405" y2="456" />
    <line x1="270" y1="40" x2="135" y2="456" />
    <line x1="270" y1="40" x2="51" y2="199" />

    <line x1="489" y1="199" x2="405" y2="456" />
    <line x1="489" y1="199" x2="135" y2="456" />
    <line x1="489" y1="199" x2="51" y2="199" />

    <line x1="405" y1="456" x2="135" y2="456" />
    <line x1="405" y1="456" x2="51" y2="199" />

    <line x1="135" y1="456" x2="51" y2="199" />

    <circle cx="270" cy="40" r="20" />
    <text x="270" y="40">0</text>

    <circle cx="489" cy="199" r="20" />
    <text x="489" y="199">1</text>

    <circle cx="405" cy="456" r="20" />
    <text x="405" y="456">2</text>

    <circle cx="135" cy="456" r="20" />
    <text x="135" y="456">3</text>

    <circle cx="51" cy="199" r="20" />
    <text x="51" y="199">4</text>
</svg>

<h3 id="cycle-graph">Cycle Graph</h3>

<p>An undirected graph where all edges form a single cycle.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="kt">long</span> <span class="n">vertexCount</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">LongValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">CycleGraph</span><span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">)</span>
    <span class="o">.</span><span class="na">generate</span><span class="o">();</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.graph.generator.CycleGraph</span>

<span class="k">val</span> <span class="n">env</span><span class="k">:</span> <span class="kt">ExecutionEnvironment</span> <span class="o">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">vertexCount</span> <span class="k">=</span> <span class="mi">5</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CycleGraph</span><span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="n">getJavaEnv</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">).</span><span class="n">generate</span><span class="o">()</span></code></pre></div>

  </div>
</div>

<svg class="graph" width="540" height="540" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

    <line x1="270" y1="40" x2="489" y2="199" />
    <line x1="489" y1="199" x2="405" y2="456" />
    <line x1="405" y1="456" x2="135" y2="456" />
    <line x1="135" y1="456" x2="51" y2="199" />
    <line x1="51" y1="199" x2="270" y2="40" />

    <circle cx="270" cy="40" r="20" />
    <text x="270" y="40">0</text>

    <circle cx="489" cy="199" r="20" />
    <text x="489" y="199">1</text>

    <circle cx="405" cy="456" r="20" />
    <text x="405" y="456">2</text>

    <circle cx="135" cy="456" r="20" />
    <text x="135" y="456">3</text>

    <circle cx="51" cy="199" r="20" />
    <text x="51" y="199">4</text>
</svg>

<h3 id="empty-graph">Empty Graph</h3>

<p>The graph containing no edges.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="kt">long</span> <span class="n">vertexCount</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">LongValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">EmptyGraph</span><span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">)</span>
    <span class="o">.</span><span class="na">generate</span><span class="o">();</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.graph.generator.EmptyGraph</span>

<span class="k">val</span> <span class="n">env</span><span class="k">:</span> <span class="kt">ExecutionEnvironment</span> <span class="o">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">vertexCount</span> <span class="k">=</span> <span class="mi">5</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">EmptyGraph</span><span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="n">getJavaEnv</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">).</span><span class="n">generate</span><span class="o">()</span></code></pre></div>

  </div>
</div>

<svg class="graph" width="540" height="80" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

    <circle cx="30" cy="40" r="20" />
    <text x="30" y="40">0</text>

    <circle cx="150" cy="40" r="20" />
    <text x="150" y="40">1</text>

    <circle cx="270" cy="40" r="20" />
    <text x="270" y="40">2</text>

    <circle cx="390" cy="40" r="20" />
    <text x="390" y="40">3</text>

    <circle cx="510" cy="40" r="20" />
    <text x="510" y="40">4</text>
</svg>

<h3 id="grid-graph">Grid Graph</h3>

<p>An undirected graph connecting vertices in a regular tiling in one or more dimensions.
Each dimension is configured separately. When the dimension size is at least three the
endpoints are optionally connected by setting <code>wrapEndpoints</code>. Changing the following
example to <code>addDimension(4, true)</code> would connect <code>0</code> to <code>3</code> and <code>4</code> to <code>7</code>.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="kt">boolean</span> <span class="n">wrapEndpoints</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">LongValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">GridGraph</span><span class="o">(</span><span class="n">env</span><span class="o">)</span>
    <span class="o">.</span><span class="na">addDimension</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">wrapEndpoints</span><span class="o">)</span>
    <span class="o">.</span><span class="na">addDimension</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">wrapEndpoints</span><span class="o">)</span>
    <span class="o">.</span><span class="na">generate</span><span class="o">();</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.graph.generator.GridGraph</span>

<span class="k">val</span> <span class="n">env</span><span class="k">:</span> <span class="kt">ExecutionEnvironment</span> <span class="o">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">wrapEndpoints</span> <span class="k">=</span> <span class="kc">false</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">GridGraph</span><span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="n">getJavaEnv</span><span class="o">).</span><span class="n">addDimension</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">wrapEndpoints</span><span class="o">).</span><span class="n">addDimension</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">wrapEndpoints</span><span class="o">).</span><span class="n">generate</span><span class="o">()</span></code></pre></div>

  </div>
</div>

<svg class="graph" width="540" height="200" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

    <line x1="30" y1="40" x2="510" y2="40" />
    <line x1="30" y1="160" x2="510" y2="160" />

    <line x1="30" y1="40" x2="30" y2="160" />
    <line x1="190" y1="40" x2="190" y2="160" />
    <line x1="350" y1="40" x2="350" y2="160" />
    <line x1="510" y1="40" x2="510" y2="160" />

    <circle cx="30" cy="40" r="20" />
    <text x="30" y="40">0</text>

    <circle cx="190" cy="40" r="20" />
    <text x="190" y="40">1</text>

    <circle cx="350" cy="40" r="20" />
    <text x="350" y="40">2</text>

    <circle cx="510" cy="40" r="20" />
    <text x="510" y="40">3</text>

    <circle cx="30" cy="160" r="20" />
    <text x="30" y="160">4</text>

    <circle cx="190" cy="160" r="20" />
    <text x="190" y="160">5</text>

    <circle cx="350" cy="160" r="20" />
    <text x="350" y="160">6</text>

    <circle cx="510" cy="160" r="20" />
    <text x="510" y="160">7</text>
</svg>

<h3 id="hypercube-graph">Hypercube Graph</h3>

<p>An undirected graph where edges form an n-dimensional hypercube. Each vertex
in a hypercube connects to one other vertex in each dimension.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="kt">long</span> <span class="n">dimensions</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">LongValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">HypercubeGraph</span><span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">dimensions</span><span class="o">)</span>
    <span class="o">.</span><span class="na">generate</span><span class="o">();</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.graph.generator.HypercubeGraph</span>

<span class="k">val</span> <span class="n">env</span><span class="k">:</span> <span class="kt">ExecutionEnvironment</span> <span class="o">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">dimensions</span> <span class="k">=</span> <span class="mi">3</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HypercubeGraph</span><span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="n">getJavaEnv</span><span class="o">,</span> <span class="n">dimensions</span><span class="o">).</span><span class="n">generate</span><span class="o">()</span></code></pre></div>

  </div>
</div>

<svg class="graph" width="540" height="320" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

    <line x1="190" y1="120" x2="350" y2="120" />
    <line x1="190" y1="200" x2="350" y2="200" />
    <line x1="190" y1="120" x2="190" y2="200" />
    <line x1="350" y1="120" x2="350" y2="200" />

    <line x1="30" y1="40" x2="510" y2="40" />
    <line x1="30" y1="280" x2="510" y2="280" />
    <line x1="30" y1="40" x2="30" y2="280" />
    <line x1="510" y1="40" x2="510" y2="280" />

    <line x1="190" y1="120" x2="30" y2="40" />
    <line x1="350" y1="120" x2="510" y2="40" />
    <line x1="190" y1="200" x2="30" y2="280" />
    <line x1="350" y1="200" x2="510" y2="280" />

    <circle cx="190" cy="120" r="20" />
    <text x="190" y="120">0</text>

    <circle cx="350" cy="120" r="20" />
    <text x="350" y="120">1</text>

    <circle cx="190" cy="200" r="20" />
    <text x="190" y="200">2</text>

    <circle cx="350" cy="200" r="20" />
    <text x="350" y="200">3</text>

    <circle cx="30" cy="40" r="20" />
    <text x="30" y="40">4</text>

    <circle cx="510" cy="40" r="20" />
    <text x="510" y="40">5</text>

    <circle cx="30" cy="280" r="20" />
    <text x="30" y="280">6</text>

    <circle cx="510" cy="280" r="20" />
    <text x="510" y="280">7</text>
</svg>

<h3 id="path-graph">Path Graph</h3>

<p>An undirected Graph where all edges form a single path.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="kt">long</span> <span class="n">vertexCount</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">LongValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">PathGraph</span><span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">)</span>
    <span class="o">.</span><span class="na">generate</span><span class="o">();</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.graph.generator.PathGraph</span>

<span class="k">val</span> <span class="n">env</span><span class="k">:</span> <span class="kt">ExecutionEnvironment</span> <span class="o">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">vertexCount</span> <span class="k">=</span> <span class="mi">5</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PathGraph</span><span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="n">getJavaEnv</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">).</span><span class="n">generate</span><span class="o">()</span></code></pre></div>

  </div>
</div>

<svg class="graph" width="540" height="80" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

    <line x1="30" y1="40" x2="510" y2="40" />

    <circle cx="30" cy="40" r="20" />
    <text x="30" y="40">0</text>

    <circle cx="150" cy="40" r="20" />
    <text x="150" y="40">1</text>

    <circle cx="270" cy="40" r="20" />
    <text x="270" y="40">2</text>

    <circle cx="390" cy="40" r="20" />
    <text x="390" y="40">3</text>

    <circle cx="510" cy="40" r="20" />
    <text x="510" y="40">4</text>
</svg>

<h3 id="rmat-graph">RMat Graph</h3>

<p>A directed or undirected power-law graph generated using the
<a href="http://www.cs.cmu.edu/~christos/PUBLICATIONS/siam04.pdf">Recursive Matrix (R-Mat)</a> model.</p>

<p>RMat is a stochastic generator configured with a source of randomness implementing the
<code>RandomGenerableFactory</code> interface. Provided implementations are <code>JDKRandomGeneratorFactory</code>
and <code>MersenneTwisterFactory</code>. These generate an initial sequence of random values which are
then used as seeds for generating the edges.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="n">RandomGenerableFactory</span><span class="o">&lt;</span><span class="n">JDKRandomGenerator</span><span class="o">&gt;</span> <span class="n">rnd</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">JDKRandomGeneratorFactory</span><span class="o">();</span>

<span class="kt">int</span> <span class="n">vertexCount</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">scale</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">edgeCount</span> <span class="o">=</span> <span class="n">edgeFactor</span> <span class="o">*</span> <span class="n">vertexCount</span><span class="o">;</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">LongValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RMatGraph</span><span class="o">&lt;&gt;(</span><span class="n">env</span><span class="o">,</span> <span class="n">rnd</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">,</span> <span class="n">edgeCount</span><span class="o">)</span>
    <span class="o">.</span><span class="na">generate</span><span class="o">();</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.graph.generator.RMatGraph</span>

<span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">vertexCount</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">scale</span>
<span class="k">val</span> <span class="n">edgeCount</span> <span class="k">=</span> <span class="n">edgeFactor</span> <span class="o">*</span> <span class="n">vertexCount</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">RMatGraph</span><span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="n">getJavaEnv</span><span class="o">,</span> <span class="n">rnd</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">,</span> <span class="n">edgeCount</span><span class="o">).</span><span class="n">generate</span><span class="o">()</span></code></pre></div>

  </div>
</div>

<p>The default RMat contants can be overridden as shown in the following example.
The contants define the interdependence of bits from each generated edge’s source
and target labels. The RMat noise can be enabled and progressively perturbs the
contants while generating each edge.</p>

<p>The RMat generator can be configured to produce a simple graph by removing self-loops
and duplicate edges. Symmetrization is performed either by a “clip-and-flip” throwing away
the half matrix above the diagonal or a full “flip” preserving and mirroring all edges.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="n">RandomGenerableFactory</span><span class="o">&lt;</span><span class="n">JDKRandomGenerator</span><span class="o">&gt;</span> <span class="n">rnd</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">JDKRandomGeneratorFactory</span><span class="o">();</span>

<span class="kt">int</span> <span class="n">vertexCount</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">scale</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">edgeCount</span> <span class="o">=</span> <span class="n">edgeFactor</span> <span class="o">*</span> <span class="n">vertexCount</span><span class="o">;</span>

<span class="kt">boolean</span> <span class="n">clipAndFlip</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">LongValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RMatGraph</span><span class="o">&lt;&gt;(</span><span class="n">env</span><span class="o">,</span> <span class="n">rnd</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">,</span> <span class="n">edgeCount</span><span class="o">)</span>
    <span class="o">.</span><span class="na">setConstants</span><span class="o">(</span><span class="mf">0.57f</span><span class="o">,</span> <span class="mf">0.19f</span><span class="o">,</span> <span class="mf">0.19f</span><span class="o">)</span>
    <span class="o">.</span><span class="na">setNoise</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="mf">0.10f</span><span class="o">)</span>
    <span class="o">.</span><span class="na">setSimpleGraph</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="n">clipAndFlip</span><span class="o">)</span>
    <span class="o">.</span><span class="na">generate</span><span class="o">();</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.graph.generator.RMatGraph</span>

<span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">vertexCount</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">scale</span>
<span class="k">val</span> <span class="n">edgeCount</span> <span class="k">=</span> <span class="n">edgeFactor</span> <span class="o">*</span> <span class="n">vertexCount</span>

<span class="n">clipAndFlip</span> <span class="k">=</span> <span class="kc">false</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">RMatGraph</span><span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="n">getJavaEnv</span><span class="o">,</span> <span class="n">rnd</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">,</span> <span class="n">edgeCount</span><span class="o">).</span><span class="n">setConstants</span><span class="o">(</span><span class="mf">0.57f</span><span class="o">,</span> <span class="mf">0.19f</span><span class="o">,</span> <span class="mf">0.19f</span><span class="o">).</span><span class="n">setNoise</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="mf">0.10f</span><span class="o">).</span><span class="n">setSimpleGraph</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="n">clipAndFlip</span><span class="o">).</span><span class="n">generate</span><span class="o">()</span></code></pre></div>

  </div>
</div>

<h3 id="singleton-edge-graph">Singleton Edge Graph</h3>

<p>An undirected graph containing isolated two-paths.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="kt">long</span> <span class="n">vertexPairCount</span> <span class="o">=</span> <span class="mi">4</span>

<span class="c1">// note: configured with the number of vertex pairs</span>
<span class="n">Graph</span><span class="o">&lt;</span><span class="n">LongValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">SingletonEdgeGraph</span><span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">vertexPairCount</span><span class="o">)</span>
    <span class="o">.</span><span class="na">generate</span><span class="o">();</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.graph.generator.SingletonEdgeGraph</span>

<span class="k">val</span> <span class="n">env</span><span class="k">:</span> <span class="kt">ExecutionEnvironment</span> <span class="o">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">vertexPairCount</span> <span class="k">=</span> <span class="mi">4</span>

<span class="c1">// note: configured with the number of vertex pairs</span>
<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SingletonEdgeGraph</span><span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="n">getJavaEnv</span><span class="o">,</span> <span class="n">vertexPairCount</span><span class="o">).</span><span class="n">generate</span><span class="o">()</span></code></pre></div>

  </div>
</div>

<svg class="graph" width="540" height="200" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

    <line x1="30" y1="40" x2="190" y2="40" />
    <line x1="350" y1="40" x2="510" y2="40" />
    <line x1="30" y1="160" x2="190" y2="160" />
    <line x1="350" y1="160" x2="510" y2="160" />

    <circle cx="30" cy="40" r="20" />
    <text x="30" y="40">0</text>

    <circle cx="190" cy="40" r="20" />
    <text x="190" y="40">1</text>

    <circle cx="350" cy="40" r="20" />
    <text x="350" y="40">2</text>

    <circle cx="510" cy="40" r="20" />
    <text x="510" y="40">3</text>

    <circle cx="30" cy="160" r="20" />
    <text x="30" y="160">4</text>

    <circle cx="190" cy="160" r="20" />
    <text x="190" y="160">5</text>

    <circle cx="350" cy="160" r="20" />
    <text x="350" y="160">6</text>

    <circle cx="510" cy="160" r="20" />
    <text x="510" y="160">7</text>
</svg>

<h3 id="star-graph">Star Graph</h3>

<p>An undirected graph containing a single central vertex connected to all other leaf vertices.</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="kt">long</span> <span class="n">vertexCount</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>

<span class="n">Graph</span><span class="o">&lt;</span><span class="n">LongValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">,</span><span class="n">NullValue</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">StarGraph</span><span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">)</span>
    <span class="o">.</span><span class="na">generate</span><span class="o">();</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.graph.generator.StarGraph</span>

<span class="k">val</span> <span class="n">env</span><span class="k">:</span> <span class="kt">ExecutionEnvironment</span> <span class="o">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="k">val</span> <span class="n">vertexCount</span> <span class="k">=</span> <span class="mi">6</span>

<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StarGraph</span><span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="n">getJavaEnv</span><span class="o">,</span> <span class="n">vertexCount</span><span class="o">).</span><span class="n">generate</span><span class="o">()</span></code></pre></div>

  </div>
</div>

<svg class="graph" width="540" height="540" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

    <line x1="270" y1="270" x2="270" y2="40" />
    <line x1="270" y1="270" x2="489" y2="199" />
    <line x1="270" y1="270" x2="405" y2="456" />
    <line x1="270" y1="270" x2="135" y2="456" />
    <line x1="270" y1="270" x2="51" y2="199" />

    <circle cx="270" cy="270" r="20" />
    <text x="270" y="270">0</text>

    <circle cx="270" cy="40" r="20" />
    <text x="270" y="40">1</text>

    <circle cx="489" cy="199" r="20" />
    <text x="489" y="199">2</text>

    <circle cx="405" cy="456" r="20" />
    <text x="405" y="456">3</text>

    <circle cx="135" cy="456" r="20" />
    <text x="135" y="456">4</text>

    <circle cx="51" cy="199" r="20" />
    <text x="51" y="199">5</text>
</svg>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

    </div>
  </div>

  
</div>

    </div><!-- /.container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.1.0/anchor.min.js"></script>
    <script src="/page/js/flink.js"></script>

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-52545728-1', 'auto');
      ga('send', 'pageview');
    </script>

    <!-- Disqus -->
    
  </body>
</html>
